\documentclass{tufte-handout}
\usepackage{braph2_dev}
%\geometry{showframe} % display margins for debugging page layout

\title{Implement a new Graph}

\author[The BRAPH~2 Developers]{The BRAPH~2 Developers}

\begin{document}

\maketitle

\begin{abstract}
\noindent
This is the developer tutorial for implementing a new graph. 
In this Tutorial, we will explain how to create the generator file \fn{*.gen.m} for a new graph which can the be compiled by \code{braph2genesis}. All graphs are extensions of the base element \code{Graph}. Here, we will use the graphs \code{GraphBD} (Binary Directed graph), \code{MultilayerWU} (Weighted Undirected multilayer graph), \code{MultiplexBUT} (Binary Undirected multiplex at fixed Thresholds), and \code{OrdMxBUT} (Binary Undirected ordinal multiplex with fixed Thresholds), as examples.
\end{abstract}

\tableofcontents

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Unilayer Graph}

\subsection{Unilayer Graph Binary Directed (GraphBD)}

We will start by implementing in detail the graph \code{GraphBD} which  is a direct extension of the element \code{Graph}.
A unilayer graph is constituted by nodes connected by edges.

\begin{lstlisting}[
	label=cd:m:GraphBD:header,
	caption={
		{\bf GraphBD element header.}
		The \code{header} section of generator code for \fn{\_GraphBD.gen.m} provides the general information about the \code{GraphBD} element.
		}
]
%% ¡header!
GraphBD < Graph (g, binary directed graph) is a binary directed graph. ¥\circled{1}\circlednote{1}{defines \code{GraphBD} as a subclass of \code{Graph}. The moniker will be \code{g}.}¥

%%% ¡description!
In a binary directed (BD) graph, the edges are directed and they can be either 0 (absence of connection) or 1 (existence of connection).
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:GraphBD:prop_update},
	caption={
		{\bf GraphBD element prop update.}
		The \code{props\_update} section of generator code for \fn{GraphBD.gen.m} updates the properties of the \code{Graph} element. This defines the core properties of the graph.
	}
]
%% ¡props_update!
%%% ¡prop!
NAME (constant, string) is the name of the binary directed graph.
%%%% ¡default!
'GraphBD'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the  binary directed graph.
%%%% ¡default!
'In a binary directed (BD) graph, the edges are directed and they can be either 0 (absence of connection) or 1 (existence of connection).'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the  binary directed graph.
¥\circlednote{1}{defines the \emph{graph type} (property \code{GRAPH\_TYPE}): \code{Graph.GRAPH} (consists of a single layer), \code{Graph.MULTIGRAPH} (multiple unconnected layers), \code{Graph.MULTILAYER} (multiple layers with categorical connections between nodes), \code{Graph.ORDERED\_MULTILAYER} (multiple layers with ordinal connections between nodes) \code{Graph.MULTIPLEX} (multilayer graph where only interlayer edges are allowed between homologous nodes), and \code{Graph.ORDERED\_MULTIPLEX} (multiplex graph that consists of a sequence of layers with ordinal edges between corresponding nodes in subsequent layers).}¥
%%% ¡prop!
ID (data, string) is a few-letter code of the  binary directed graph.
%%%% ¡default!
'GraphBD ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the binary directed graph.
%%%% ¡default!
'GraphBD label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the binary directed graph.
%%%% ¡default!
'GraphBD notes'

%%% ¡prop! ¥\circled{1}¥
GRAPH_TYPE (constant, scalar) returns the graph type __Graph.GRAPH__.
%%%% ¡default! ¥\circlednote{2}{Graphs have a \emph{connectivity type} (\code{CONNECTIVITY\_TYPE}): \code{Graph.BINARY} (graph with binary, 0 or 1, connections) or \code{Graph.WEIGHTED} (graph with weighted connections).}¥
Graph.GRAPH

%%% ¡prop! ¥\circled{2}¥
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type __Graph.BINARY__. ¥\circlednote{3}{Graphs have a \emph{directionality type} (\code{DIRECTIONALITY\_TYPE}): \code{Graph.DIRECTED} (graph with directed edges) or \code{Graph.UNDIRECTED} (graph with undirected edges). }¥
%%%% ¡default!
value = Graph.BINARY;

%%% ¡prop! ¥\circled{3}¥¥\circlednote{4}{Graphs have a \emph{self-connectivity type} (\code{SELFCONNECTIVITY\_TYPE}): \code{Graph.NONSELFCONNECTED} (graph without self-connections) or \code{Graph.SELFCONNECTED} (graph with self-connections). }¥
DIRECTIONALITY_TYPE  (query, smatrix) returns the directionality type __Graph.DIRECTED__.
%%%% ¡default! 
value = Graph.DIRECTED;

%%% ¡prop! ¥\circled{4}¥ ¥\circlednote{5}{Graphs have a \emph{negativity type} (\code{NEGATIVITY\_TYPE}): \code{Graph.NONNEGATIVE} (graph without negative edges) or \code{Graph.NEGATIVE} (graph allowing negative edges). }¥
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__.
%%%% ¡default!
value = Graph.NONSELFCONNECTED;

%%% ¡prop! ¥\circled{5}¥¥\circlednote{6}{The property \code{A} contains the supra-adjacency matrix of the graph, which is calculated by the code under \code{¡calculate!}.}¥
NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__.
%%%% ¡default! ¥\circlednote{7}{retrieves the adjacency matrix of the graph, defined in the new properties below.}¥
value = Graph.NONNEGATIVE;

%%% ¡prop! ¥\circled{6}\circlednote{8}{\circled{9} \circled{10} condition the adjaciency matrix removing the diagonal elements, making it semidefinte positive, and binarizing it. A list of useful functions is: \code{diagonalize} (removes the off-diagonal), \code{dediagonalize} (removes the diagonal), \code{binarize} (binarizes with threshold=0), \code{semipositivize} (removes negative weights), \code{standardize} (normalizes between 0 and 1) or \code{symmetrize} (symmetrizes the matrix). Use the MatLab help to see additional functionalities.}¥
A (result, cell) is the binary adjacency matrix of the binary directed graph.
%%%% ¡calculate!
B = g.get('B'); ¥\circled{7}¥

B = dediagonalize(B);  ¥\circled{8}¥
B = semipositivize(B, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE')); ¥\circled{9}¥
B = binarize(B); ¥\circled{10}¥

A = {B}; ¥\circled{11}\circlednote{11}{preallocates the adjacency matrix that contains the result of the defined graph.}¥
value = A; ¥\circled{12}\circlednote{12}{returns the calcualted graph \code{A} assigning it to the output variable \code{value}.}¥

%%%% ¡gui! ¥\circled{13}\circlednote{13}{Each graph has a panel figure of the cell containing the calculated graph adjacency matrix \code{A}.}¥
pr = PanelPropCell('EL', g, 'PROP', GraphBD.A, ... ¥\circled{14}\circlednote{14}{ \code{PanelPropCell} plots the panel for a CELL property with a table and two sliders. It can be personalized with props, e.g., \code{TABLE\_HEIGHT} (height in pixels), \code{XSLIDERSHOW} (whether to show the x-slider),  or \code{COLUMNAME} (string list with column names)}¥
'TABLE_HEIGHT', s(40), ... 
'XSLIDERSHOW', false, ... 
'YSLIDERSHOW', false, ...  
'ROWNAME' , g.getCallback('ANODELABELS'), ... 
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
);

%%% ¡prop! ¥\circled{15}\circlednote{15}{Each graph has a list of compatible measures.}¥
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures('GraphBD')
\end{lstlisting}



\begin{lstlisting}[
	label={cd:m:GraphBD:props},
	caption={
		{\bf GraphBD element props.}
		The \code{props} section of generator code for \fn{GraphBD.gen.m} defines the properties to be used in \fn{GraphBD}.
	}
	]
%% ¡props!

%%% ¡prop!¥\circled{1}\circlednote{1}{Each graph has a panel figure of the input graph adjacency matrix  \code{B}.}¥
B (data, smatrix) is the input graph adjacency matrix.
%%%% ¡gui!
pr = PanelPropMatrix('EL', g, 'PROP', GraphBD.B, ... ¥\circled{2}\circlednote{2}{ \code{PanelPropMatrix} plots the panel of a property matrix-like with a table. It can be personalized with props as in \circled{12}. Here it plots the input graph adjacency matrix \code{B}}¥
'TABLE_HEIGHT' , s(40), ...
'ROWNAME' , g.getCallback('ANODELABELS'), ... 
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
varargin{:});

%%% ¡prop! ¥\circled{3}\circlednote{3}{Each graph have different rules that need to be defined: \code{SYMMETRIZE\_RULE}: symmetrizes the matrix A by the symmetrize rule specified by RULE and the admissible RULE options are: 'max' (default,maximum between inconnection and outconnection), 'sum' (convert negative values to absolute value), 'average' (average of inconnection and outconnection) or 'min' (minimum between inconnection and outconnection) \code{SEMIPOSITIVIZE\_RULE}: determines how to remove the negative edges and the admissible RULE options are: 'zero' (default, convert negative values to zeros) or 'absolute' (convert negative values to absolute value) \code{STANDARDIZE\_RULE }: determines how to normalize the weights between 0 and 1 and the admissible RULE options are: 'threshold' (default, normalizes the matrix A by converting negative values to zero and values larger than 1 to 1) or  'range' (normalizes the matrix A in order to have values scaled between 0 and 1 by using a linear function). }¥
SEMIPOSITIVIZE_RULE (parameter, option) determines how to remove the negative edges.
%%%% ¡settings!
{'zero', 'absolute'}

\end{lstlisting}

\clearpage


\begin{lstlisting}[
	label=cd:m:GraphBD:tests,
	caption={
		{\bf GraphBD element tests.}
		The \code{tests} section from the element generator \fn{\_GraphBD.gen.m}.
		A general test should be prepared to test the properties of the graph  when it is empty and full. Furthermore, additional tests should be prepared for the rules defined (one test per rule).
	}
	]			
%% ¡tests!

%%% ¡excluded_props!  ¥\circled{1}\circlednote{1}{List of properties that are excluded from testing.}¥
[GraphBD.PFGA GraphBD.PFGH]

%%% ¡test!
%%%% ¡name!
Constructor - Empty  ¥\circled{2}\circlednote{2}{checks that an empty \fn{GraphBD} graph is constructing well}¥
%%%% ¡probability! ¥\circled{3}\circlednote{3}{assigns a low test execution probability}¥
.01
%%%% ¡code!
B = []; ¥\circled{4}\circlednote{4}{initializes an empty \fn{GraphBD} graph}¥
g = GraphBD('B', B);¥\circled{5}\circlednote{5}{constructs the \fn{GraphBD} graph from the initialized \fn{B}}¥

g.get('A_CHECK'); ¥\circled{6}\circlednote{6}{performs the corresponding checks for the format of the adjacency matrix \code{A}: \code{GRAPH\_TYPE}, \code{CONNECTIVITY\_TYPE}, \code{DIRECTIONALITY\_TYPE}, \code{SELFCONNECTIVITY\_TYPE} and \code{NEGATIVITY\_TYPE}.}¥

A = {binarize(semipositivize(dediagonalize(B)))}; ¥\circled{7}\circlednote{7}{calculates the value of the graph by apply the corresponding properties function}¥
assert(isequal(g.get('A'), A), ...¥\circled{8}\circlednote{8}{tests that the value of generated graph calculated by applying the properties functions coincides with the expected value}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Constructor - Full ¥\circled{9}\circlednote{9}{checks that a full \fn{GraphBD} graph is constructing well}¥
%%%% ¡probability!  ¥\circled{3}¥
.01  ¥\circled{3}¥
%%%% ¡code!
B = randn(randi(10)); ¥\circled{10}\circlednote{10}{generates a random graph}¥
g = GraphBD('B', B);  ¥\circled{5}¥

g.get('A_CHECK') ¥\circled{6}¥

A = {binarize(semipositivize(dediagonalize(B)))}; ¥\circled{7}¥
assert(isequal(g.get('A'), A), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Semipositivize Rules ¥\circled{11}\circlednote{11}{checks the \fn{SEMIPOSITIVIZE\_RULE} on the \fn{GraphBD} graph.}¥
%%%% ¡probability!
.01 ¥\circled{3}¥
%%%% ¡code!
B = [
-2 -1 0 1 2
-1 0 1 2 -2
0 1 2 -2 -1
1 2 -2 -1 0
2 -2 -1 0 1
]; ¥\circled{12}\circlednote{12}{generates an example graph with negative weights}¥

g0 = GraphBD('B', B);  ¥\circled{13}\circlednote{13}{constructs the \fn{GraphBD} graph from the initialized \fn{B} with default RULE for \fn{SEMIPOSITIVIZE\_RULE}. }¥
A0 = {[
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]};  ¥\circled{14}\circlednote{14}{Expected value of the graph calculated by external means}¥
assert(isequal(g0.get('A'), A0), ...  ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

g_zero = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'zero'); ¥\circled{15}\circlednote{15}{constructs the \fn{GraphBD} graph from the initialized \fn{B} with RULE = 'zero' for \fn{SEMIPOSITIVIZE\_RULE}. }¥
A_zero = {[
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]}; ¥\circled{14}¥
assert(isequal(g_zero.get('A'), A_zero), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

g_absolute = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'absolute'); ¥\circled{16}\circlednote{16}{constructs the \fn{GraphBD} graph from the initialized \fn{B} with RULE = 'absolute' for \code{SEMIPOSITIVIZE\_RULE}}¥
A_absolute = {[
	0 1 0 1 1
	1 0 1 1 1
	0 1 0 1 1
	1 1 1 0 0
	1 1 1 0 0
	]}; ¥\circled{14}¥
assert(isequal(g_absolute.get('A'), A_absolute), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

¤...¤
\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Multilayer Graph}

\subsection{Multilayer Weigthed Directed Graph (MultilayerWD )}

We can now use \code{GraphBD} as the basis to implement the \code{MultilayerWD} graph. The parts of the code that are modified are highlighted.

A multilayer network allows connections between any nodes across the multiple layers, where all layers are interconnected following a categorical fashion.

\begin{lstlisting}[
	label=cd:m:MultilayerWD:header,
	caption={
		{\bf MultilayerWD element header.}
		The \code{header} section of generator code for \fn{\_MultilayerWD.gen.m} provides the general information about the \code{MultilayerWD} element.
		\expand{cd:m:GraphBD:header}
	}
]
¤%% ¡header!¤
MultilayerWD ¤< Graph¤ (g, multilayer weighted directed graph) is a multilayer weighted directed graph.

¤%%% ¡description!¤
In a multilayer weighted directed (WD) graph, layers could have different number of nodes with within-layer weighted directed edges, associated with a real number between 0 and 1 and indicating the strength of the connection. The connectivity matrices are symmetric (within layer). All node connections are allowed between layers.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:prop_update,
	caption={
		{\bf MultilayerWD element prop update.}
		The \code{props\_update} section of generator code for \fn{\_MultilayerWD.gen.m} updates the properties of \code{MultilayerWD}.
		\expand{cd:m:GraphBD:prop_update}
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'In a multilayer weighted directed (WD) graph, layers could have different number of nodes with within-layer weighted directed edges, associated with a realnumber between 0 and 1 and indicating the strength of the connection. The connectivity matrices are symmetric (within layer). All node connections are allowed between layers.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤multilayer weighted directed graph¤.¤

¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD notes'

¤%%% ¡prop!
GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.MULTILAYER__.
%%%% ¡default!
Graph.MULTILAYER

¤%%% ¡prop!
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type¤ __Graph.WEIGHTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.WEIGHTED * ones(layernumber);

¤%%% ¡prop!
DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type¤ __Graph.DIRECTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.DIRECTED * ones(layernumber);

¤%%% ¡prop!
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type¤ __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.SELFCONNECTED * ones(layernumber);
value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                

¤%%% ¡prop!
NEGATIVITY_TYPE (query, smatrix) returns the negativity type ¤__Graph.NONNEGATIVE__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
	layernumber = 1;
else
	layernumber = varargin{1};
end
value = Graph.NONNEGATIVE * ones(layernumber);

¤%%% ¡prop!
A (result, cell) is the cell containing¤ the within-layer weighted adjacency
matrices of the multilayer weighted directed graph and the connections
between layers.

¤%%%% ¡calculate!
B = g.get('B'); ¤
L = length(B); 
A = cell(L, L);
for i = 1:1:L ¥\circled{1}\circlednote{1}{For each layer in \fn{MultilayerWD} graph the corresponding functions are applied as in  \expand{cd:m:GraphBD:prop_update} \circled{8, 9 10}}¥
	M = dediagonalize(B{i,i}); 
	M = semipositivize(M, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE'));
	M = standardize(M, 'StandardizeRule', g.get('STANDARDIZE_RULE'));  
	A(i, i) = {M};
	if ~isempty(A{i, i})
		for j = i+1:1:L
			M = semipositivize(B{i,j}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(i, j) = {M};
			M = semipositivize(B{j,i}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(j, i) = {M};
		end
	end
end
¤value = A;¤


¤%%%% ¡gui!
pr = PanelPropCell('EL', g, 'PROP', ¤MultilayerWD.A, ...
¤'TABLE_HEIGHT', s(40), ...¤
'XYSLIDERLOCK', true, ... 
¤'XSLIDERSHOW', false, ...
'YSLIDERSHOW', true, ...¤
'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
'YSLIDERWIDTH', s(5), ...
¤'ROWNAME', g.getCallback('ANODELABELS'), ...
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
varargin{:});¤¥\circlednote{2}{There are some properties of graph adjacency matrix \code{A} that can be used in the gui to make the visualization user friendly. The list of properties that can be used are: ALAYERTICKS (to set ticks for each layer according to the layer number), ALAYERLABELS (to set labels for each layer), ANODELABELS (to set the nodel labels for each layer))}¥

%%% ¡prop!
PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.
%%%% ¡calculate!
value = ones(1, g.get('LAYERNUMBER'));

%%% ¡prop!
ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.¥\circled{2}¥
%%%% ¡calculate!
alayerlabels = g.get('LAYERLABELS'); ¥\circled{3}\circlednote{3}{returns the labels of the graph layers provided by the user}¥
if isempty(alayerlabels) && ~isa(g.getr('A'), 'NoValue') % ensures that it's not unecessarily calculated
	alayerlabels = cellfun(@num2str, num2cell([1:1:g.get('LAYERNUMBER')]), 'uniformoutput', false); ¥\circled{4}\circlednote{4}{constructs the labels of the layers based on the number of the layer (in case no layer labels were provided by the user).}¥
end
value = alayerlabels;

¤%%% ¡prop!
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures¤('MultilayerWD')


\end{lstlisting}



\begin{lstlisting}[
label={cd:m:MultilayerWD:props},
caption={
	{\bf MultilayerWD element props.}
	The \code{props} section of generator code for \fn{MultilayerWD.gen.m} defines the properties to be used in \fn{MultilayerWD}.
	\expand{cd:m:GraphBD:props}
}
]

%% ¡props!

%%% ¡prop!
B (data, cell) is the input cell containing the multilayer adjacency matrices.
%%%% ¡default!
{[] []; [] []}
%%%% ¡gui! ¥\circled{1}\circlednote{1}{Same as in \expand{cd:m:GraphBD:props} \circled{2}}¥
pr = PanelPropCell('EL', g, 'PROP', MultilayerWD.B, ...
'TABLE_HEIGHT', s(40), ...
'XSLIDERSHOW', true, ...
'XSLIDERLABELS', g.get('LAYERLABELS'), ...
'XSLIDERHEIGHT', s(3.5), ...
'YSLIDERSHOW', false, ...
'ROWNAME', g.getCallback('ANODELABELS'), ...
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
varargin{:});


¤%%% ¡prop!
SEMIPOSITIVIZE_RULE (parameter, option) determines how to remove the negative edges.
%%%% ¡settings!
{'zero', 'absolute'}¤

%%% ¡prop!  ¥\circled{2}\circlednote{2}{Same as in  \expand{cd:m:GraphBD:props} \circled{3}}¥
STANDARDIZE_RULE (parameter, option) determines how to normalize the weights between 0 and 1.
%%%% ¡settings!
{'threshold' 'range'}

\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:tests,
	caption={
		{\bf MultilayerWD element tests.}
		The \code{tests} section from the element generator \fn{\_MultilayerWD.gen.m}.
		\expand{cd:m:GraphBD:tests}
	}
]
¤%% ¡tests!

%%% ¡excluded_props!¤
[MultilayerWD.PFGA MultilayerWD.PFGH]

¤%%% ¡test!
%%%% ¡name!
Constructor - Full
%%%% ¡probability!
.01
%%%% ¡code!¤
B1 = rand(randi(10));
B2 = rand(randi(10));
B3 = rand(randi(10));
B12 = rand(size(B1, 1),size(B2, 2));
B13 = rand(size(B1, 1),size(B3, 2));
B23 = rand(size(B2, 1),size(B3, 2));
B21 = rand(size(B2, 1),size(B1, 2));
B31 = rand(size(B3, 1),size(B1, 2));
B32 = rand(size(B3, 1),size(B2, 2));
B = {
	B1                           B12                            B13
	B21                          B2                             B23
	B31                          B32                            B3
};
g = MultilayerWD('B', B);
¤g.get('A_CHECK')¤
A1 = standardize(semipositivize(dediagonalize(B1)));
A2 = standardize(semipositivize(dediagonalize(B2)));
A3 = standardize(semipositivize(dediagonalize(B3)));
A12 = standardize(semipositivize(B12));
A13 = standardize(semipositivize(B13));
A23 = standardize(semipositivize(B23));
A21 = standardize(semipositivize(B21));
A31 = standardize(semipositivize(B31));
A32 = standardize(semipositivize(B32));
B{1,1} = A1;
B{2,2} = A2;
B{3,3} = A3;
B{1,2} = A12;
B{1,3} = A13;
B{2,3} = A23;
B{2,1} = A21;
B{3,1} = A31;
B{3,2} = A32;
A = B;
¤assert(isequal(g.get('A'), A), ...¤
¤[BRAPH2.STR ':¤ MultilayerWD:¤ ' BRAPH2.FAIL_TEST], ...¤
'MultilayerWD  is not constructing well.')

\end{lstlisting}


\clearpage

\subsection{Multiplex Binary Undirected with fixed Thresholds Graph (MultiplexBUT)}

Now we implement the \code{MultiplexBUT} graph based on previous codes \code{GraphBD} and \code{MultilayerWD}, again highlighting the differences.

A multiplex graph is a type of multilayer graph where only interlayer edges are allowed between homologous nodes. In this case, the layers follow a categorical architecture, which means that all layers are interconnected.


\begin{lstlisting}[
	label=cd:m:MultiplexBUT:header,
	caption={
		{\bf MultiplexBUT element header.}
		The \code{header} section of generator code for \fn{\_MultiplexBUT.gen.m} provides the general information about the \code{MultiplexBUT} element.
		\expand{cd:m:GraphBD:header}
	}
	]
	¤%% ¡header!¤
	MultiplexBUT < MultiplexWU (g, binary undirected multiplex with fixed
	thresholds) is a binary undirected multiplex with fixed thresholds. ¥\circled{1}\circlednote{1}{MultiplexBUT is a child of \fn{MultiplexWU} graph}¥
	
	¤%%% ¡description!¤
	In a binary undirected multiplex with fixed thresholds (BUT), the layers are those of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds.The supra-connectivity matrix has a number of partitions equal to the number of thresholds.

\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultiplexBUT:prop_update,
	caption={
		{\bf MultiplexBUT element prop update.}
		The \code{props\_update} section of generator code for \fn{\_MultiplexBUT.gen.m} updates the properties of \code{MultiplexBUT}.
		\expand{cd:m:GraphBD:prop_update}
	}
	]
	¤%% ¡props_update!¤
	
	¤%%% ¡prop!
	NAME (constant, string) is the name of the ¤binary undirected multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'MultiplexBUT'
	
	¤%%% ¡prop!
	DESCRIPTION (constant, string) is the description of the ¤binary undirected
	multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'In a binary undirected multiplex with fixed thresholds (BUT), the layers are those of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds.'

	¤%%% ¡prop!
	TEMPLATE (parameter, item) is the template of the ¤binary undirected multiplex with fixed thresholds¤.¤
	
	¤%%% ¡prop!
	ID (data, string) is a few-letter code of the ¤binary undirected multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'MultiplexBUT ID'
	
	¤%%% ¡prop!
	LABEL (metadata, string) is an extended label of the ¤binary undirected multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'MultiplexBUT label'
	
	¤%%% ¡prop!
	NOTES (metadata, string) are some specific notes about the ¤binary undirected multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'MultiplexBUT notes'
	
	¤%%% ¡prop!
	GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.MULTIPLEX__.
	%%%% ¡default!
	Graph.MULTIPLEX
	
	¤%%% ¡prop!
	CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type¤ __Graph.BINARY__  * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
		layernumber = 1;
	else
		layernumber = varargin{1};
	end
	value = Graph.BINARY * ones(layernumber); 
	
	¤%%% ¡prop!
	DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type¤ __Graph.UNDIRECTED__ * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
		layernumber = 1;
	else
		layernumber = varargin{1};
	end
	value = Graph.UNDIRECTED * ones(layernumber);
	
	¤%%% ¡prop!
	SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
	%%%% ¡calculate!
	if isempty(varargin)
		layernumber = 1;
	else
		layernumber = varargin{1};
	end
	value = Graph.SELFCONNECTED * ones(layernumber);
	value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                
	
	%%% ¡prop!
	NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__ * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
		layernumber = 1;
	else
		layernumber = varargin{1};
	end
	value = Graph.NONNEGATIVE * ones(layernumber);¤
	
	¤%%% ¡prop!
	A (result, cell) is the cell containing¤ multiplex binary adjacency matrices of the binary undirected multiplex.
	
	¤%%%% ¡calculate!¤
	A_WU = calculateValue@MultiplexWU(g, prop);¥\circled{1}\circlednote{1}{calculates the graph MultiplexWU calling its parent \fn{MultiplexWU}.}¥
	
	thresholds = g.get('THRESHOLDS'); ¥\circled{2}\circlednote{2}{gets the thresholds to be applied to \fn{A\_WU}.}¥
	L = length(A_WU); % number of layers ¥\circled{3}\circlednote{3}{gets the number of layers in graph \fn{A\_WU}.}¥
	A = cell(length(thresholds)*L); ¥\circled{4}\circlednote{4}{The new \fn{MultiplexBUT} graph will have \fn{L} layers for each threshold applied.}¥
	
	if L > 0 && ~isempty(cell2mat(A_WU))
		A(:, :) = {eye(length(A_WU{1, 1}))};
		for i = 1:1:length(thresholds) ¥\circled{5}\circlednote{5}{iterates over all the thresholds to be applied}¥
			threshold = thresholds(i);
			layer = 1;
			for j = (i - 1) * L + 1:1:i * L ¥\circled{6}\circlednote{6}{iterates over all the layers in \fn{A\_WU} }¥
				A{j, j} = dediagonalize(binarize(A_WU{layer, layer}, 'threshold', threshold)); ¥\circled{7}\circlednote{7}{binarizes the present layer of the \fn{A\_WU} graph according to the present threshold}¥
				layer = layer + 1;
			end
		end
	end
	
	¤value = A;¤


	¤%%%% ¡gui! ¥\circled{8}\circlednote{8}{Same as in \expand{cd:m:GraphBD:prop_update} \circled{2}}¥
	pr = PanelPropCell('EL', g, 'PROP', MultiplexBUT.A, ...
	'TABLE_HEIGHT', s(40), ...
	'XYSLIDERLOCK', true, ... 
	'XSLIDERSHOW', false, ...
	'YSLIDERSHOW', true, ...
	'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
	'YSLIDERWIDTH', s(5), ...
	'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});¤
	
	¤%%% ¡prop!
	PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.¤
	%%%% ¡calculate!
	l = g.get('LAYERNUMBER');
	thresholds = g.get('THRESHOLDS');
	value = ones(1, length(thresholds)) * l / length(thresholds);
	
	¤%%% ¡prop!
	ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.
	%%%% ¡calculate!
	alayerlabels = g.get('LAYERLABELS');¤
	if ~isa(g.getr('A'), 'NoValue') && length(alayerlabels) ~= g.get('LAYERNUMBER') % ensures that it's not unecessarily calculated
		thresholds = cellfun(@num2str, num2cell(g.get('THRESHOLDS')), 'uniformoutput', false);

		if length(alayerlabels) == length(g.get('B'))
			blayerlabels = alayerlabels;
		else % includes isempty(layerlabels)
			blayerlabels = cellfun(@num2str, num2cell([1:1:length(g.get('B'))]), 'uniformoutput', false);
		end
	
		alayerlabels = {};
		for i = 1:1:length(thresholds)¥\circled{9}\circlednote{9}{sets the labels of layers considering the thresholds and the number of layers in each multiplex graph for each threshold}¥
			for j = 1:1:length(blayerlabels)
				alayerlabels = [alayerlabels, [blayerlabels{j} '|' thresholds{i}]];
			end
		end
	end
	value = alayerlabels;
	
	¤%%% ¡prop! 
	COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
	%%%% ¡default!
	getCompatibleMeasures('MultiplexBUT')¤
	
\end{lstlisting}



\begin{lstlisting}[
label={cd:m:MultiplexBUT:props},
caption={
	{\bf MultiplexBUT element props.}
	The \code{props} section of generator code for \fn{MultiplexBUT.gen.m} defines the properties to be used in \fn{MultiplexBUT}.
	\expand{cd:m:GraphBD:props}
}
]

	
	%% ¡props!
	
	%%% ¡prop!
	THRESHOLDS (parameter, rvector) is the vector of thresholds.
	%%%% ¡gui! ¥\circled{1}\circlednote{1}{\code{PanelPropRVectorSmart} plots the panel for a row vector with an edit field. Smart means that (almost) any MatLab expression leading to a correct row vector can be introduced in the edit field. Also, the value of the vector can be limited between some MIN and MAX.}¥
	pr = PanelPropRVectorSmart('EL', g, 'PROP', MultiplexBUT.THRESHOLDS, 'MAX', 1, 'MIN', -1, varargin{:});
	
	
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultiplexBUT:tests,
	caption={
		{\bf MultiplexBUT element tests.}
		The \code{tests} section from the element generator \fn{\_MultiplexBUT.gen.m}.
		\expand{cd:m:GraphBD:tests}
	}
	]
	%% ¡tests!
	
	%%% ¡test!
	%%%% ¡name!
	Constructor - Full
	%%%% ¡probability!
	.01
	%%%% ¡code!
	B1 = [
	0 .1 .2 .3 .4 
	.1 0 .1 .2 .3
	.2 .1 0 .1 .2
	.3 .2 .1 0 .1
	.4 .3 .2 .1 0
	]; 
	B = {B1, B1, B1}; ¥\circled{1}\circlednote{1}{creates and example MultiplexWU}¥
	thresholds = [0 .1 .2 .3 .4]; ¥\circled{2}\circlednote{2}{defines some example thresholds}¥
	g = MultiplexBUT('B', B, 'THRESHOLDS', thresholds);
	
	g.get('A_CHECK')
	
	A = g.get('A');
	for i = 1:1:length(B) * length(thresholds)
		for j = 1:1:length(B) * length(thresholds)
			if i == j
				threshold = thresholds(floor((i - 1) / length(B)) + 1);
				assert(isequal(A{i, i}, binarize(B1, 'threshold', threshold)), ...
				[BRAPH2.STR ':MultiplexBUT:' BRAPH2.FAIL_TEST], ...
				'MultiplexBUT is not constructing well.')
			else
				assert(isequal(A{i, j}, eye(length(B1))), ...
				[BRAPH2.STR ':MultiplexBUT:' BRAPH2.FAIL_TEST], ...
				'MultiplexBUT is not constructing well.')            
			end
		end
	end
	
\end{lstlisting}



\clearpage

\subsection{Ordinal Multiplex Binary Undirected with fixed Thresholds Graph (OrdMxBUT)}

Finally, we implement the \code{OrdMxBUT} graph based on previous codes \code{GraphBD}, \code{MultilayerWD} and \code{MultiplexBUT}, again highlighting the differences. An ordered multiplex is a type of multiplex graph that consists of a sequence of layers with ordinal edges between corresponding nodes in subsequent layers.


\begin{lstlisting}[
	label=cd:m:OrdMxBUT:header,
	caption={
		{\bf OrdMxBUT element header.}
		The \code{header} section of generator code for \fn{\_OrdMxBUT.gen.m} provides the general information about the \code{OrdMxBUT} element.
		\expand{cd:m:GraphBD:header}
	}
	]
	¤%% ¡header!¤
	OrdMxBUT < OrdMxWU (g, ordinal multiplex binary undirected with fixed thresholds) is a binary undirected ordinal multiplex with fixed thresholds. ¥\circled{1}\circlednote{1}{OrdMxBUT is a child of \fn{OrdMxWU} graph}¥
	
	¤%%% ¡description!¤
	In a binary undirected ordinal multiplex with fixed thresholds (BUT), all the layers consist of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds. The layers are connected in an ordinal fashion, i.e., only consecutive layers are connected.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:OrdMxBUT:prop_update,
	caption={
		{\bf OrdMxBUT element prop update.}
		The \code{props\_update} section of generator code for \fn{\_OrdMxBUT.gen.m} updates the properties of \code{OrdMxBUT}.
		\expand{cd:m:GraphBD:prop_update}
	}
	]
	¤%% ¡props_update!¤
	
	¤%%% ¡prop!
	NAME (constant, string) is the name of the ¤binary undirected ordinal multiplex with fixed thresholds.s¤.
	%%%% ¡default!¤
	'OrdMxBUT'
	
	¤%%% ¡prop!
	DESCRIPTION (constant, string) is the description of the ¤binary undirected ordinal multiplex with fixed thresholds.¤.
	%%%% ¡default!¤
	'In a binary undirected ordinal multiplex with fixed thresholds (BUT), all the layers consist of binary undirected (BU) multiplex graphs derived from the same weighted supra-connectivity matrices binarized at different thresholds. The supra-connectivity matrix has a number of partitions equal to the number of thresholds. The layers are connectedin an ordinal fashion, i.e., only consecutive layers are connected.'
	
	¤%%% ¡prop!
	TEMPLATE (parameter, item) is the template of the ¤binary undirected ordinal multiplex with fixed thresholds¤.¤
	
	¤%%% ¡prop!
	ID (data, string) is a few-letter code of the ¤binary undirected ordinal multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'OrdMxBUT ID'
	
	¤%%% ¡prop!
	LABEL (metadata, string) is an extended label of the ¤binary undirected ordinal multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'OrdMxBUT label'
	
	¤%%% ¡prop!
	NOTES (metadata, string) are some specific notes about the ¤binary undirected ordinal multiplex with fixed thresholds¤.
	%%%% ¡default!¤
	'OrdMxBUT notes'
	
	¤%%% ¡prop!
	GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.ORDERED_MULTIPLEX__.
	%%%% ¡default!
	Graph.ORDERED_MULTIPLEX
	
	¤%%% ¡prop!
	CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type __Graph.BINARY__  * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
	layernumber = 1;
	else
	layernumber = varargin{1};
	end
	value = Graph.BINARY * ones(layernumber); ¤
	
	¤%%% ¡prop!
	DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type __Graph.UNDIRECTED__ * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
	layernumber = 1;
	else
	layernumber = varargin{1};
	end
	value = Graph.UNDIRECTED * ones(layernumber);¤
	
	¤%%% ¡prop!
	SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
	%%%% ¡calculate!
	if isempty(varargin)
	layernumber = 1;
	else
	layernumber = varargin{1};
	end
	value = Graph.SELFCONNECTED * ones(layernumber);
	value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                
	
	%%% ¡prop!
	NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__ * ones(layernumber).
	%%%% ¡calculate!
	if isempty(varargin)
	layernumber = 1;
	else
	layernumber = varargin{1};
	end
	value = Graph.NONNEGATIVE * ones(layernumber);¤
	
	¤%%% ¡prop!
	A (result, cell) is the cell containing¤binary supra-adjacency matrix of the binary undirected multiplex with fixed thresholds (BUT).
	
	¤%%%% ¡calculate!¤
	A_WU = calculateValue@OrdMxWU(g, prop);¥\circled{1}\circlednote{1}{calculates the graph OrdMxWU calling the parent \fn{OrdMxWU}.}¥
	
	¤thresholds = g.get('THRESHOLDS');  ¥\circled{2}\circlednote{2}{Same as in \expand{cd:m:MultiplexBUT:prop_update}  \circled{2}-\circled{4}.}¥
	L = length(A_WU); % number of layers 
	A = cell(length(thresholds)*L);¤
	
	if L > 0 && ~isempty(cell2mat(A_WU))
		A(:, :) = {zeros(length(A_WU{1, 1}))};
		for i = 1:1:length(thresholds) ¥\circled{3}\circlednote{3}{For each threshold we construct an ordinal muliplex binary undirected graph}¥
			threshold = thresholds(i);
			layer = 1;
			for j = (i - 1) * L + 1:1:i * L ¥\circled{4}\circlednote{4}{We need to loop over the layers of \fn{A\_Wu} for each threshold}¥
				for k = (i - 1) * L + 1:1:i * L
					if j == k ¥\circled{5}\circlednote{5}{In the diagonal of the supra-adjacency matrix we have the layers that are constructed by binarizing \fn{A\_Wu} accorsing to the present threshold}¥
						A{j, j} = dediagonalize(binarize(A_WU{layer, layer}, 'threshold', threshold));
					elseif (j-k)==1 || (k-j)==1 ¥\circled{6}\circlednote{6}{Consecutive layers are connected}¥
						A(j, k) = {eye(length(A{1, 1}))};
					else ¥\circled{7}\circlednote{7}{Non-consecutive layers are not connected}¥
						A(j, k) = {zeros(length(A{1, 1}))};
					end
				end
				layer = layer + 1;
			end
		end
	end
	
	¤value = A;¤
	
	¤%%%% ¡gui! ¥\circled{8}\circlednote{8}{Same as in \expand{cd:m:MultiplexBUT:gui}}¥
	pr = PanelPropCell('EL', g, 'PROP', OrdMxBUT.A, ...
	'TABLE_HEIGHT', s(40), ...
	'XYSLIDERLOCK', true, ... 
	'XSLIDERSHOW', false, ...
	'YSLIDERSHOW', true, ...
	'YSLIDERLABELS', g.getCallback('ALAYERLABELS'), ...
	'YSLIDERWIDTH', s(5), ...
	'ROWNAME', g.getCallback('ANODELABELS'), ...
	'COLUMNNAME', g.getCallback('ANODELABELS'), ...
	varargin{:});¤
	
	¤%%% ¡prop!
	PARTITIONS (result, rvector) returns the number of layers in the partitions of the graph.
	%%%% ¡calculate!
	l = g.get('LAYERNUMBER');
	thresholds = g.get('THRESHOLDS');
	value = ones(1, length(thresholds)) * l / length(thresholds);¤
	
	¤%%% ¡prop!
	ALAYERLABELS (query, stringlist) returns the layer labels to be used by the slider.
	%%%% ¡calculate!
	alayerlabels = g.get('LAYERLABELS');
	if ~isa(g.getr('A'), 'NoValue') && length(alayerlabels) ~= g.get('LAYERNUMBER') % ensures that it's not unecessarily calculated
		thresholds = cellfun(@num2str, num2cell(g.get('THRESHOLDS')), 'uniformoutput', false);
	
		if length(alayerlabels) == length(g.get('B'))
			blayerlabels = alayerlabels;
		else % includes isempty(layerlabels)
			blayerlabels = cellfun(@num2str, num2cell([1:1:length(g.get('B'))]), 'uniformoutput', false);
		end
		
		alayerlabels = {};
		for i = 1:1:length(thresholds)
			for j = 1:1:length(blayerlabels)
				alayerlabels = [alayerlabels, [blayerlabels{j} '|' thresholds{i}]];
			end
		end
	end
	value = alayerlabels;¤
	
	¤%%% ¡prop!
	COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
	%%%% ¡default!
	getCompatibleMeasures('OrdMxBUT')¤
	
	
\end{lstlisting}



\begin{lstlisting}[
label={cd:m:OrdMxBUT:props},
caption={
	{\bf OrdMxBUT element props.}
	The \code{props} section of generator code for \fn{OrdMxBUT.gen.m} defines the properties to be used in \fn{MultiplexBUT}.
	\expand{cd:m:GraphBD:props}
}
]

¤%% ¡props!

%%% ¡prop!
THRESHOLDS (parameter, rvector) is the vector of thresholds.
%%%% ¡gui!
pr = PanelPropRVectorSmart('EL', g, 'PROP', ¤OrdMxBUT.THRESHOLDS, ¤'MAX', 1, 'MIN', -1, varargin{:});¤
	
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:OrdMxBUT:tests,
	caption={
		{\bf OrdMxBUT element tests.}
		The \code{tests} section from the element generator \fn{\_OrdMxBUT.gen.m}.
		\expand{cd:m:GraphBD:tests}
	}
	]
	%% ¡tests!
	
	%%% ¡excluded_props!
	[OrdMxBUT.PFGA OrdMxBUT.PFGH]
	
	¤%%% ¡test!
	%%%% ¡name!
	Constructor - Full ¥\circled{1}\circlednote{1}{same as in \expand{cd:m:MultiplexBUT:tests}.}¥
	%%%% ¡probability!
	.01
	%%%% ¡code!
	B1 = [
	0 .1 .2 .3 .4 
	.1 0 .1 .2 .3
	.2 .1 0 .1 .2
	.3 .2 .1 0 .1
	.4 .3 .2 .1 0
	];
	B = {B1, B1, B1};
	thresholds = [0 .1 .2 .3 .4];¤
	g = OrdMxBUT('B', B, 'THRESHOLDS', thresholds);
	
	¤g.get('A_CHECK')
	
	A = g.get('A');¤
	for i = 1:1:length(thresholds)
		threshold = thresholds(i);
		for j = (i - 1) * length(B) + 1:1:i * length(B)
			for k = (i - 1) * length(B) + 1:1:i * length(B)
				if j == k
					assert(isequal(A{j, j}, binarize(B1, 'threshold', threshold)), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
				elseif (j-k)==1 || (k-j)==1
					assert(isequal(A{j, k}, eye(length(B1))), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
				else 
					assert(isequal(A{j, k}, zeros(length(B1))), ...
					[BRAPH2.STR ':OrdMxBUT:' BRAPH2.FAIL_TEST], ...
					'OrdMxBUT is not constructing well.')
				end
			end
		end
	end
	
\end{lstlisting}

%\bibliography{biblio}
%\bibliographystyle{plainnat}

\end{document}