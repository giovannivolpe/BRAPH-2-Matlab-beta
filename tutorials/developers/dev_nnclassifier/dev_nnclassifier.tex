\documentclass{tufte-handout}
\usepackage{../braph2_dev}
%\geometry{showframe} % display margins for debugging page layout

\title{Implement a new Neural Network Classifier}

\author[The BRAPH~2 Developers]{The BRAPH~2 Developers}

\begin{document}

\maketitle

\begin{abstract}
\noindent
This is the developer tutorial for implementing a new neural network classifier. 
In this Tutorial, we will explain how to create the generator file \fn{*.gen.m} for a new neural network classifier, which can then be compiled by \code{braph2genesis}. All kinds of neural network models are (direct or indirect) extensions of the base element \code{NNBase}. Here, we will use as examples the neural network classifier \code{NNClassifierMLP} (multi-layer perceptron classifier).
\end{abstract}

\tableofcontents

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of a Neural Network Classifier}

We will start by implementing in detail \code{NNClassifierMLP}, which is a direct extension of \code{NNBase}.
A multi-layer perceptron classifier \code{NNClassifierMLP} comprises a multi-layer perceptron classifier model and a given dataset.

\begin{lstlisting}[
	label=cd:m:NNClassifierMLP:header,
	caption={
		{\bf NNClassifierMLP element header.}
		The \code{header} section of the generator code for \fn{\_NNClassifierMLP.gen.m} provides the general information about the \code{NNClassifierMLP} element.
		}
]
%% ¡header!
NNClassifierMLP < NNBase (nn, multi-layer perceptron classifier) comprises a multi-layer perceptron classifier model and a given dataset.  ¥\circled{1}\circlednote{1}{defines \code{NNClassifierMLP} as a subclass of \code{NNBase}. The moniker will be \code{nn}}¥

%%% ¡description!
A neural network multi-layer perceptron classifier (NNClassifierMLP) comprises a multi-layer perceptron classifier model and a given dataset.
NNClassifierMLP trains the multi-layer perceptron classifier with a formatted inputs ("CB", channel and batch) derived from the given dataset.
\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNClassifierMLP:prop_update},
	caption={
		{\bf NNClassifierMLP element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNClassifierMLP.gen.m} updates the properties of the \code{NNClassifierMLP} element. This defines the core properties of the data point.
	}
]
%% ¡props_update!

%%% ¡prop!
NAME (constant, string) is the name of the neural network multi-layer perceptron classifier.
%%%% ¡default!
'NNClassifierMLP'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the neural network multi-layer perceptron classifier.
%%%% ¡default!
'A neural network multi-layer perceptron classifier (NNClassifierMLP) comprises a multi-layer perceptron classifier model and a given dataset. NNClassifierMLP trains the multi-layer perceptron classifier with a formatted inputs ("CB", channel and batch) derived from the given dataset.'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the neural network multi-layer perceptron classifier.
%%%% ¡settings!
'NNClassifierMLP'

%%% ¡prop!
ID (data, string) is a few-letter code for the neural network multi-layer perceptron classifier.
%%%% ¡default!
'NNClassifierMLP ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the neural network multi-layer perceptron classifier.
%%%% ¡default!
'NNClassifierMLP label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the neural network multi-layer perceptron classifier.
%%%% ¡default!
'NNClassifierMLP notes'

%%% ¡prop! ¥\circled{1}\circlednote{1}{defines \code{NNDataset} which contains the \code{NNDataPoint} to train this classifier}¥
D (data, item) is the dataset to train the neural network model, and its data point class DP_CLASS defaults to one of the compatible classes within the set of DP_CLASSES.
%%%% ¡settings!
'NNDataset'
%%%% ¡default!
NNDataset('DP_CLASS', 'NNDataPoint_CON_CLA')

%%% ¡prop!
DP_CLASSES (parameter, classlist) is the list of compatible data points. 
%%%% ¡default! ¥\circled{2}\circlednote{2}{defines the compatible \code{NNDataPoint} classes with this \code{NNClassifierMLP}.}¥
{'NNDataPoint_CON_CLA' 'NNDataPoint_CON_FUN_MP_CLA' 'NNDataPoint_Graph_CLA' 'NNDataPoint_Measure_CLA'}

%%% ¡prop!
INPUTS (query, cell) constructs the data in the CB (channel-batch) format.
%%%% ¡calculate! ¥\circled{3}\circlednote{3}{is a query that transforms the input data of \code{NNDataPoint} to the CB (channel-batch) format by flattening its included cells.}¥
% inputs = nn.get('inputs', D) returns a cell array with the
%  inputs for all data points in dataset D.
if isempty(varargin)
    value = {};
    return
end
d = varargin{1};
inputs_group = d.get('INPUTS');
if isempty(inputs_group)
    value = {};
else
    flattened_inputs_group = [];
    for i = 1:1:length(inputs_group)
        inputs_individual = inputs_group{i};
        flattened_inputs_individual = [];
        while ~isempty(inputs_individual)
            currentData = inputs_individual{end};  % Get the last element from the stack
            inputs_individual = inputs_individual(1:end-1);   % Remove the last element

            if iscell(currentData)
                % If it's a cell array, add its contents to the stack
                inputs_individual = [inputs_individual currentData{:}];
            else
                % If it's numeric or other data, append it to the vector
                flattened_inputs_individual = [currentData(:); flattened_inputs_individual];
            end
        end
        flattened_inputs_group = [flattened_inputs_group; flattened_inputs_individual'];
    end
    value = {flattened_inputs_group};
end

%%% ¡prop!
TARGETS (query, cell) constructs the targets in the CB (channel-batch) format with one-hot vectors.
%%%% ¡calculate! ¥\circled{4}\circlednote{4}{is a query that construct the one-hot vectors for the target classes.}¥
% targets = nn.get('TARGETS', D) returns a cell array with the
%  targets for all data points in dataset D with one-hot vectors.
if isempty(varargin)
    value = {};
    return
end
d = varargin{1};

target_ids = nn.get('TARGET_IDS', d);
value = onehotencode(categorical(target_ids), 2);

%%% ¡prop!
MODEL (result, net) is a trained neural network model.
%%%% ¡calculate! ¥\circled{5}\circlednote{5}{trains the classifier with the defined dataset.}¥
inputs = cell2mat(nn.get('INPUTS', nn.get('D'))); ¥\circled{6}¥
targets = nn.get('TARGET_IDS', nn.get('D')); ¥\circled{7}\twocirclednotes{6}{7}{firstly extract the inputs and targets with the corresponding format.}¥
if isempty(inputs) || isempty(targets)
    value = network();
else
    number_features = size(inputs, 2);
    number_targets = size(targets, 2);
    targets = categorical(targets); 
    number_classes = numel(categories(targets));
    
    layers = nn.get('LAYERS'); ¥\circled{8}\circlednote{8}{defines the neural network architecture with user specified number of neurons and number of layers.}¥
    nn_architecture = [featureInputLayer(number_features, 'Name', 'Input')];
    for i = 1:1:length(layers)
        nn_architecture = [nn_architecture
            fullyConnectedLayer(layers(i), 'Name', ['Dense_' num2str(i)])
            batchNormalizationLayer('Name', ['BatchNormalization_' num2str(i)])
            dropoutLayer('Name', ['Dropout_' num2str(i)])
            ];
    end
    nn_architecture = [nn_architecture
        reluLayer('Name', 'Relu_output')
        fullyConnectedLayer(number_classes, 'Name', 'Dense_output')
        softmaxLayer
        classificationLayer('Name', 'Output')
        ];

    % specify trianing options  ¥\circled{9}\circlednote{9}{defines the neural network training options.}¥
    options = trainingOptions(nn.get('SOLVER'), ...
        'MiniBatchSize', nn.get('BATCH'), ...
        'MaxEpochs', nn.get('EPOCHS'), ...
        'Shuffle', nn.get('SHUFFLE'), ...
        'Plots', nn.get('PLOT_TRAINING'), ...
        'Verbose', nn.get('VERBOSE'));

    % train the neural network ¥\circled{10}\circlednote{10}{trains the model with those parameters and the neural network architecture.}¥
    value = trainNetwork(inputs, targets, nn_architecture, options);
end


\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNClassifierMLP:props},
	caption={
		{\bf NNClassifierMLP element props.}
		The \code{props} section of generator code for \fn{\_NNClassifierMLP.gen.m} defines the properties to be used in \fn{NNClassifierMLP}.
	}
]
%% ¡props!

%%% ¡prop!
TARGET_IDS (query, stringlist) constructs the target IDs which represent the class of each data point.
%%%% ¡calculate!
% targets = nn.get('TARGET_IDS', D) returns a cell array with the
%  targets for all data points in dataset D.
if isempty(varargin)
    value = {''};
    return
end
d = varargin{1};
targets = d.get('TARGETS');
if isempty(targets)
    value = {''};
else
    nn_targets = [];
    for i = 1:1:length(targets)
        target = targets{i};
        nn_targets = [nn_targets; target];
    end
    value = nn_targets;
end

%%% ¡prop!
LAYERS (data, rvector) defines the number of layers and their neurons.
%%%% ¡default!
[32 32]
%%%% ¡gui!
pr = PanelPropRVectorSmart('EL', nn, 'PROP', NNClassifierMLP.LAYERS, ...
    'MIN', 0, 'MAX', 2000, ...
    'DEFAULT', NNClassifierMLP.getPropDefault('LAYERS'), ...
    varargin{:});

%%% ¡prop!
WAITBAR (gui, logical) detemines whether to show the waitbar.
%%%% ¡default!
true

%%% ¡prop!
INTERRUPTIBLE (gui, scalar) sets whether the comparison computation is interruptible for multitasking.
%%%% ¡default!
.001

%%% ¡prop!
FEATURE_IMPORTANCE (query, cell) evaluates the average significance of each feature by iteratively shuffling its values P times and measuring the resulting average decrease in model performance.
%%%% ¡calculate!
% fi = nn.get('FEATURE_IMPORTANCE', D, P, SEED) retrieves a cell array containing
%  the feature importance values for the trained model, as assessed by
%  evaluating it on the input dataset D.
if isempty(varargin)
    value = {};
    return
end
d = varargin{1};
P = varargin{2};
seeds = varargin{3};

inputs = cell2mat(nn.get('INPUTS', d));
if isempty(inputs)
    value = {};
    return
end
targets = nn.get('TARGETS', d);
net = nn.get('MODEL');

number_features = size(inputs, 2);
original_loss = crossentropy(net.predict(inputs), targets);

wb = braph2waitbar(nn.get('WAITBAR'), 0, ['Feature importance permutation ...']);

start = tic;
for i = 1:1:P
    rng(seeds(i), 'twister')
    parfor j = 1:1:number_features
        scrambled_inputs = inputs;
        permuted_value = squeeze(normrnd(mean(inputs(:, j)), std(inputs(:, j)), squeeze(size(inputs(:, j))))) + squeeze(randn(size(inputs(:, j)))) + mean(inputs(:, j));
        scrambled_inputs(:, j) = permuted_value;
        scrambled_loss = crossentropy(net.predict(scrambled_inputs), targets);
        feature_importance(j) = scrambled_loss;
    end

    feature_importance_all_permutations{i} = feature_importance / original_loss;

    braph2waitbar(wb, i / P, ['Feature importance permutation ' num2str(i) ' of ' num2str(P) ' - ' int2str(toc(start)) '.' int2str(mod(toc(start), 1) * 10) 's ...'])
    if nn.get('VERBOSE')
        disp(['** PERMUTATION FEATURE IMPORTANCE - sampling #' int2str(i) '/' int2str(P) ' - ' int2str(toc(start)) '.' int2str(mod(toc(start), 1) * 10) 's'])
    end
    if nn.get('INTERRUPTIBLE')
        pause(nn.get('INTERRUPTIBLE'))
    end
end

braph2waitbar(wb, 'close')

value = feature_importance_all_permutations;
\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_CON_REG:tests,
	caption={
		{\bf NNDataPoint\_CON\_REG element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_CON\_REG.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]			
%% ¡tests!

%%% ¡excluded_props!  ¥\circled{1}\circlednote{1}{List of properties that are excluded from testing.}¥
[NNDataPoint_CON_REG.SUB]

%%% ¡test!
%%%% ¡name!
Create example files for regression  ¥\circled{2}\circlednote{2}{creates the example connectivity data files for regression analysis.}¥
%%%% ¡code!
data_dir = [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS'];
if ~isdir(data_dir)
    mkdir(data_dir);

    % Brain Atlas  ¥\circled{3}\circlednote{3}{creates and exports the brain atlas file to the example directory.}¥
    im_ba = ImporterBrainAtlasXLS('FILE', 'desikan_atlas.xlsx');
    ba = im_ba.get('BA');
    ex_ba = ExporterBrainAtlasXLS( ...
        'BA', ba, ...
        'FILE', [data_dir filesep() 'atlas.xlsx'] ...
        );
    ex_ba.get('SAVE')
    N = ba.get('BR_DICT').get('LENGTH');

    % saves RNG
    rng_settings_ = rng(); rng('default')

    sex_options = {'Female' 'Male'};

    % Group ¥\circled{4}\circlednote{4}{creates one group of subjects with specified degree and rewiring probability configurations.}¥
    K = 2; % degree (mean node degree is 2K)
    beta = 0.3; % Rewiring probability
    gr_name = 'CON_Group_XLS';
    gr_dir = [data_dir filesep() gr_name];
    mkdir(gr_dir);
    vois = [
        {{'Subject ID'} {'Age'} {'Sex'}}
        {{} {} cell2str(sex_options)}
        ];
    for i = 1:1:100 % subject number
        sub_id = ['SubjectCON_' num2str(i)];
        % create WS graphs with random beta
        beta(i) = rand(1); ¥\circled{5}\circlednote{5}{generates random rewiring probability settings for each subject.}¥
        h = WattsStrogatz(N, K, beta(i)); % create WS graph ¥\circled{6} \twocirclednotes{6}{10}{utilize the provided degree and rewiring probability settings to generate corresponding Watts-Strogatz model graphs.}¥

        A = full(adjacency(h)); A(1:length(A)+1:numel(A)) = 0; % extract the adjacency matrix
        r = 0 + (0.5 - 0) * rand(size(A)); diffA = A - r; A(A ~= 0) = diffA(A ~= 0); % make the adjacency matrix weighted
        A = max(A, transpose(A)); % make the adjacency matrix symmetric

        writetable(array2table(A), [gr_dir filesep() sub_id '.xlsx'], 'WriteVariableNames', false) ¥\circled{7}\circlednote{7}{exports the adjacency matrix of the graph to an Excel file.}¥

        % variables of interest
        age_upperBound = 80;
        age_lowerBound = 50;
        age = age_lowerBound + beta(i)*(age_upperBound - age_lowerBound); ¥\circled{8}\circlednote{8}{associates the age value with each individual rewiring probability setting.}¥
        vois = [vois; {sub_id, age, sex_options(randi(2))}];
    end
    writetable(table(vois), [data_dir filesep() gr_name '.vois.xlsx'], 'WriteVariableNames', false) ¥\circled{9}\circlednote{9}{exports the variables of interest to an Excel file.}¥

    % reset RNG
    rng(rng_settings_)
end
%%% ¡test_functions!
function h = WattsStrogatz(N, K, beta) ¥\circled{10}¥
% H = WattsStrogatz(N,K,beta) returns a Watts-Strogatz model graph with N
% nodes, N*K edges, mean node degree 2*K, and rewiring probability beta.
%
% beta = 0 is a ring lattice, and beta = 1 is a random graph.

% Connect each node to its K next and previous neighbors. This constructs
% indices for a ring lattice.
    s = repelem((1:N)', 1, K);
    t = s + repmat(1:K, N, 1);
    t = mod(t - 1, N) + 1;
    
    % Rewire the target node of each edge with probability beta
    for source = 1:N
        switchEdge = rand(K, 1) < beta;
        
        newTargets = rand(N, 1);
        newTargets(source) = 0;
        newTargets(s(t == source)) = 0;
        newTargets(t(source, ~switchEdge)) = 0;
        
        [~, ind] = sort(newTargets, 'descend');
        t(source, switchEdge) = ind(1:nnz(switchEdge));
    end
    
    h = graph(s,t);
end

%%% ¡test! 
%%%% ¡name! ¥\circled{11}\circlednote{11}{validates the data point by using assertions to confirm that the input and target calculated values match the connectivity data and the variables of interest in the example files.}¥
Create a NNDataset containg NNDataPoint_CON_REG with simulated data
%%%% ¡code!
% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Group of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'CON_Group_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

% create an item list of NNDataPoint_CON_REG ¥\circled{12}\threecirclednotes{12}{13}{14}{creates an item list for the data points, subsequently generates the data point dictionary using the list, and then constructs the neural network dataset containing these data points.}¥
it_list = cellfun(@(x) NNDataPoint_CON_REG( ...
    'ID', x.get('ID'), ...
    'SUB', x, ...
    'TARGET_IDS', x.get('VOI_DICT').get('KEYS')), ...
    gr.get('SUB_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create a NNDataPoint_CON_REG DICT ¥\circled{13}¥
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_CON_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_CON_REG DICT ¥\circled{14}¥
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_CON_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the number of inputs matches ¥\circled{14}\circlednote{14}{tests the number of inputs from the dataset matches the number of subjects in the group.}¥
assert(length(d.get('INPUTS')) == gr.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_REG:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_REG does not construct the dataset correctly. The number of the inputs should be the same as the number of imported subjects.' ...
		)

% Check whether the number of targets matches ¥\circled{15}\circlednote{15}{tests the number of targets from the dataset matches the number of subjects in the group.}¥
assert(length(d.get('TARGETS')) == gr.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_REG:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_REG does not construct the dataset correctly. The number of the targets should be the same as the number of imported subjects.' ...
		)

% Check whether the content of input for a single datapoint matches ¥\circled{16}\circlednote{16}{tests the value of each input from the data point matches the subject's connectivity data.}¥
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = {gr.get('SUB_DICT').get('IT', index).get('CON')};

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_CON_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_CON_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test! 
%%%% ¡name!  ¥\circled{17}\circlednote{17}{executes the corresponding example scripts to ensure the functionalities.}¥
Example training-test regression
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end

example_NN_CON_REG

\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\subsection{Connectivity Data Point for Classification (\code{NNDataPoint\_CON\_CLA})}

We can now use \code{NNDataPoint\_CON\_REG} as the basis to implement the \code{NNDataPoint\_CON\_CLA}.
The parts of the code that are modified are highlighted. 

\begin{lstlisting}[
	label=cd:m:NNDataPoint_CON_CLA:header,
	caption={
		{\bf NNDataPoint\_CON\_CLA element header.}
		The \code{header} section of the generator code for \fn{\_NNDataPoint\_CON\_CLA.gen.m} provides the general information about the \code{NNDataPoint\_CON\_CLA} element.
		}
]
¤%% ¡header!¤
NNDataPoint_CON_CLA ¤< NNDataPoint¤ (dp, connectivity classification data point) is a data point for classification with connectivity data.

¤%%% ¡description!¤
A data point for classification with connectivity data (NNDataPoint_CON_CLA) 
contains the input and target for neural network analysis with a subject with connectivity data (SubjectCON).
The input is the connectivity data of the subject.
The target is obtained from the variables of interest of the subject.
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:NNDataPoint_CON_CLA:prop_update},
	caption={
		{\bf NNDataPoint\_CON\_CLA element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNDataPoint\_CON\_CLA.gen.m} updates the properties of the \code{NNDataPoint\_CON\_CLA} element. This defines the core properties of the data point.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of a data point for ¤classification¤ with connectivity data.
%%%% ¡default!¤
'NNDataPoint_CON_CLA'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of a data point for ¤classification¤ with connectivity data.
%%%% ¡default!¤
'A data point for classification with connectivity data (NNDataPoint_CON_CLA) contains the input and target for neural network analysis with a subject with connectivity data (SubjectCON). The input is the connectivity data of the subject. The target is obtained from the variables of interest of the subject.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of a data point for ¤classification¤ with connectivity data.
%%%% ¡settings!¤
'NNDataPoint_CON_CLA'

¤%%% ¡prop!
ID (data, string) is a few-letter code for a data point for ¤classification¤ with connectivity data.
%%%% ¡default!¤
'NNDataPoint_CON_CLA ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of a data point for ¤classification¤ with connectivity data.
%%%% ¡default!¤
'NNDataPoint_CON_CLA label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about a data point for ¤classification¤ with connectivity data.
%%%% ¡default!¤
'NNDataPoint_CON_CLA notes'

¤%%% ¡prop!
INPUT (result, cell) is the input value for this data point.
%%%% ¡calculate!
value = {dp.get('SUB').get('CON')};¤
    
¤%%% ¡prop!
TARGET (result, stringlist) is the target values for this data point.
%%%% ¡calculate!¤
value = dp.get('TARGET_IDS'); 

\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_CON_CLA:props},
	caption={
		{\bf NNDataPoint\_CON\_CLA element props.}
		The \code{props} section of generator code for \fn{\_NNDataPoint\_CON\_CLA.gen.m} defines the properties to be used in \fn{NNDataPoint\_CON\_CLA}.
	}
]
¤%% ¡props!¤

¤%%% ¡prop!
SUB (data, item) is a subject with connectivity data.
%%%% ¡settings!
'SubjectCON'¤

¤%%% ¡prop!¤ ¥\circled{1}\circlednote{1}{defines the target value using the data point's label in the form of a string list, e.g., 'Group1'.}¥
¤TARGET_IDS (parameter, stringlist) is a list of variable-of-interest IDs to be used as ¤the class targets.

\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_CON_CLA:tests,
	caption={
		{\bf NNDataPoint\_CON\_CLA element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_CON\_CLA.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]			
¤%% ¡tests!¤

¤%%% ¡excluded_props!¤
[NNDataPoint_CON_CLA.SUB]

¤%%% ¡test!
%%%% ¡name!
Create example files
%%%% ¡code!¤
data_dir = [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS'];
¤if ~isdir(data_dir)
    mkdir(data_dir);

    % Brain Atlas
    im_ba = ImporterBrainAtlasXLS('FILE', 'desikan_atlas.xlsx');
    ba = im_ba.get('BA');
    ex_ba = ExporterBrainAtlasXLS( ...
        'BA', ba, ...
        'FILE', [data_dir filesep() 'atlas.xlsx'] ...
        );
    ex_ba.get('SAVE')
    N = ba.get('BR_DICT').get('LENGTH');

    % saves RNG
    rng_settings_ = rng(); rng('default')

    sex_options = {'Female' 'Male'};¤

    % Group 1  ¥\circled{1}\circlednote{1}{creates the first group of simulated data.}¥
    K1 = 2; % degree (mean node degree is 2K) - group 1
    beta1 = 0.3; % Rewiring probability - group 1
    gr1_name = 'CON_Group_1_XLS';
    gr1_dir = [data_dir filesep() gr1_name];
    mkdir(gr1_dir);
    vois1 = [
        {{'Subject ID'} {'Age'} {'Sex'}}
        {{} {} cell2str(sex_options)}
        ];
    for i = 1:1:50 % subject number
        sub_id = ['SubjectCON_' num2str(i)];

        h1 = WattsStrogatz(N, K1, beta1); % create two WS graph
        % figure(1) % Plot the two graphs to double-check
        % plot(h1, 'NodeColor',[1 0 0], 'EdgeColor',[0 0 0], 'EdgeAlpha',0.1, 'Layout','circle');
        % title(['Group 1: Graph with $N = $ ' num2str(N_nodes) ...
        %     ' nodes, $K = $ ' num2str(K1) ', and $\beta = $ ' num2str(beta1)], ...
        %     'Interpreter','latex')
        % axis equal

        A1 = full(adjacency(h1)); A1(1:length(A1)+1:numel(A1)) = 0; % extract the adjacency matrix
        r = 0 + (0.5 - 0)*rand(size(A1)); diffA = A1 - r; A1(A1 ~= 0) = diffA(A1 ~= 0); % make the adjacency matrix weighted
        A1 = max(A1, transpose(A1)); % make the adjacency matrix symmetric

        writetable(array2table(A1), [gr1_dir filesep() sub_id '.xlsx'], 'WriteVariableNames', false)

        % variables of interest
        vois1 = [vois1; {sub_id, randi(90), sex_options(randi(2))}];
    end
    writetable(table(vois1), [data_dir filesep() gr1_name '.vois.xlsx'], 'WriteVariableNames', false)

    % Group 2 ¥\circled{2}\twocirclednotes{2}{3}{create the second group of simulated data with different rewiring probability parameter.}¥
    K2 = 2; % degree (mean node degree is 2K) - group 2
    beta2 = 0.85; % Rewiring probability - group 2 ¥\circled{3}¥
    gr2_name = 'CON_Group_2_XLS';
    gr2_dir = [data_dir filesep() gr2_name];
    mkdir(gr2_dir);
    vois2 = [
        {{'Subject ID'} {'Age'} {'Sex'}}
        {{} {} cell2str(sex_options)}
        ];
    for i = 51:1:100
        sub_id = ['SubjectCON_' num2str(i)];

        h2 = WattsStrogatz(N, K2, beta2);
        % figure(2)
        % plot(h2, 'NodeColor',[1 0 0], 'EdgeColor',[0 0 0], 'EdgeAlpha',0.1, 'Layout','circle');
        % title(['Group 2: Graph with $N = $ ' num2str(N_nodes) ...
        %     ' nodes, $K = $ ' num2str(K2) ', and $\beta = $ ' num2str(beta2)], ...
        %     'Interpreter','latex')
        % axis equal

        A2 = full(adjacency(h2)); A2(1:length(A2)+1:numel(A2)) = 0;
        r = 0 + (0.5 - 0)*rand(size(A2)); diffA = A2 - r; A2(A2 ~= 0) = diffA(A2 ~= 0);
        A2 = max(A2, transpose(A2));

        writetable(array2table(A2), [gr2_dir filesep() sub_id '.xlsx'], 'WriteVariableNames', false)

        % variables of interest
        vois2 = [vois2; {sub_id, randi(90), sex_options(randi(2))}];
    end
    writetable(table(vois2), [data_dir filesep() gr2_name '.vois.xlsx'], 'WriteVariableNames', false)

    % Group 3 ¥\circled{4}\twocirclednotes{4}{5}{create the third group of simulated data with different rewiring probability parameter.}¥
    K3 = 2; % degree (mean node degree is 2K) - group 2
    beta3 = 0.55; % Rewiring probability - group 2  ¥\circled{5}¥
    gr3_name = 'CON_Group_3_XLS';
    gr3_dir = [data_dir filesep() gr3_name];
    mkdir(gr3_dir);
    vois3 = [
        {{'Subject ID'} {'Age'} {'Sex'}}
        {{} {} cell2str(sex_options)}
        ];
    for i = 101:1:150
        sub_id = ['SubjectCON_' num2str(i)];

        h3 = WattsStrogatz(N, K3, beta3);
        % figure(2)
        % plot(h2, 'NodeColor',[1 0 0], 'EdgeColor',[0 0 0], 'EdgeAlpha',0.1, 'Layout','circle');
        % title(['Group 2: Graph with $N = $ ' num2str(N_nodes) ...
        %     ' nodes, $K = $ ' num2str(K2) ', and $\beta = $ ' num2str(beta2)], ...
        %     'Interpreter','latex')
        % axis equal

        A3 = full(adjacency(h3)); A3(1:length(A3)+1:numel(A3)) = 0;
        r = 0 + (0.5 - 0)*rand(size(A3)); diffA = A3 - r; A3(A3 ~= 0) = diffA(A3 ~= 0);
        A3 = max(A3, transpose(A3));

        writetable(array2table(A3), [gr3_dir filesep() sub_id '.xlsx'], 'WriteVariableNames', false)

        % variables of interest
        vois3 = [vois3; {sub_id, randi(90), sex_options(randi(2))}];
    end
    writetable(table(vois3), [data_dir filesep() gr3_name '.vois.xlsx'], 'WriteVariableNames', false)

    ¤% reset RNG
    rng(rng_settings_)
end¤

¤%%% ¡test_functions!
function h = WattsStrogatz(N,K,beta)
% H = WattsStrogatz(N,K,beta) returns a Watts-Strogatz model graph with N
% nodes, N*K edges, mean node degree 2*K, and rewiring probability beta.
%
% beta = 0 is a ring lattice, and beta = 1 is a random graph.

% Connect each node to its K next and previous neighbors. This constructs
% indices for a ring lattice.
s = repelem((1:N)',1,K);
t = s + repmat(1:K,N,1);
t = mod(t-1,N)+1;

% Rewire the target node of each edge with probability beta
for source=1:N
    switchEdge = rand(K, 1) < beta;
    
    newTargets = rand(N, 1);
    newTargets(source) = 0;
    newTargets(s(t==source)) = 0;
    newTargets(t(source, ~switchEdge)) = 0;
    
    [~, ind] = sort(newTargets, 'descend');
    t(source, switchEdge) = ind(1:nnz(switchEdge));
end

h = graph(s,t);
end¤

¤%%% ¡test! 
%%%% ¡name!¤
Create a NNDataset containg NNDataPoint_CON_CLA with simulated data
¤%%%% ¡code!
% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');¤

% Load Groups of SubjectCON  ¥\circled{6}\circlednote{6}{imports two groups of simulated data.}¥
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_1_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_2_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% create item lists of NNDataPoint_CON_CLA  ¥\circled{7}\circlednote{7}{creates two datasets for the two groups.}¥
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_CON_CLA( ...
    'ID', x.get('ID'), ...
    'SUB', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    gr1.get('SUB_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_CON_CLA( ...
    'ID', x.get('ID'), ...
    'SUB', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    gr2.get('SUB_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_CON_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_CON_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_CON_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_CON_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_CON_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_CON_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the number of inputs matches ¥\circled{8}\circlednote{8}{tests the number of inputs from the dataset matches the number of subjects in the group.}¥
assert(length(d1.get('INPUTS')) == gr1.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_CLA does not construct the dataset correctly. The number of the inputs should be the same as the number of imported subjects of group 1.' ...
		)

assert(length(d2.get('INPUTS')) == gr2.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_CLA does not construct the dataset correctly. The number of the inputs should be the same as the number of imported subjects of group 2.' ...
		)

% Check whether the number of targets matches ¥\circled{9}\circlednote{9}{tests the number of targets from the dataset matches the number of subjects in the group.}¥
assert(length(d1.get('TARGETS')) == gr1.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_CLA does not construct the dataset correctly. The number of the targets should be the same as the number of imported subjects of group 1.' ...
		)

assert(length(d2.get('TARGETS')) == gr2.get('SUB_DICT').get('LENGTH'), ...
		[BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
		'NNDataPoint_CON_CLA does not construct the dataset correctly. The number of the targets should be the same as the number of imported subjects of group 2.' ...
		)

% Check whether the content of input for a single datapoint matches ¥\circled{10}\circlednote{10}{tests the value of each input from the data point matches the subject's connectivity data.}¥
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = {gr1.get('SUB_DICT').get('IT', index).get('CON')};

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_CON_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = {gr2.get('SUB_DICT').get('IT', index).get('CON')};

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_CON_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_CON_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

¤%%% ¡test! 
%%%% ¡name!
Example training-test ¤classification¤ ¥\circled{11}\circlednote{11}{executes the corresponding example scripts to ensure the functionalities.}¥
%%%% ¡code!
% ensure the example data is generated¤
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
¤end¤

example_NN_CON_CLA

\end{lstlisting}


%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of a Data Point with a Graph}
\subsection{Graph Data Point for Regression (\code{NNDataPoint\_Graph\_REG})}

Now we implement \code{NNDataPoint\_Graph\_REG} based on previous codes \code{NNDataPoint\_CON\_REG}.
This neural network datapoint with graphs utilizes the adjacency matrix extracted from the derived graph of the subject. 
The modified parts of the code are highlighted.

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Graph_REG:header,
	caption={
		{\bf NNDataPoint\_Graph\_REG element header.}
		The \code{header} section of the generator code for \fn{\_NNDataPoint\_Graph\_REG.gen.m} provides the general information about the \code{NNDataPoint\_Graph\_REG} element.
		}
]
¤%% ¡header!¤
NNDataPoint_Graph_REG ¤< NNDataPoint (dp, measure regressioni data point) is a data point for regression with¤ a graph.

¤%%% ¡description!¤
A data point for regression with a graph (NNDataPoint_Graph_REG) 
 contains both input and target for neural network analysis.
The input is the value of the adjacency matrix extracted from the derived graph of the subject.
The target is obtained from the variables of interest of the subject.
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:NNDataPoint_Graph_REG:prop_update},
	caption={
		{\bf NNDataPoint\_Graph\_REG element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNDataPoint\_Graph\_REG.gen.m} updates the properties of the \code{NNDataPoint\_Graph\_REG} element. This defines the core properties of the data point.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of a data point for regression with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_REG'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of a data point for regression with ¤a graph¤.
%%%% ¡default!¤
'A data point for regression with a graph (NNDataPoint_Graph_REG) contains both input and target for neural network analysis. The input is the value of the adjacency matrix extracted from the derived graph of the subject. The target is obtained from the variables of interest of the subject.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of a data point for regression with ¤a graph¤.
%%%% ¡settings!¤
'NNDataPoint_Graph_REG'

¤%%% ¡prop!
ID (data, string) is a few-letter code for a data point for regression with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_REG ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of a data point for regression with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_REG label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about a data point for regression with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_REG notes'

¤%%% ¡prop!
INPUT (result, cell) is the input value for this data point.
%%%% ¡calculate!¤
value = dp.get('G').get('A');  ¥\circled{1}\circlednote{1}{extracts the adjacency matrix from a \code{Graph} element as the input for this data point. Note that a \code{Graph} can be any kind of \code{Graph}, including \code{GraphWU}, \code{MultigraphBUD}, and \code{MultiplexBUT}, among others.}¥
    
¤%%% ¡prop!
TARGET (result, cell) is the target value for this data point.
%%%% ¡calculate!
value = cellfun(@(x) dp.get('SUB').get('VOI_DICT').get('IT', x).get('V'), dp.get('TARGET_IDS'), 'UniformOutput', false);¤

\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_Graph_REG:props},
	caption={
		{\bf NNDataPoint\_Graph\_REG element props.}
		The \code{props} section of generator code for \fn{\_NNDataPoint\_Graph\_REG.gen.m} defines the properties to be used in \fn{NNDataPoint\_Graph\_REG}.
	}
]
¤%% ¡props!¤

%%% ¡prop!  ¥\circled{1}\circlednote{1}{defines the \code{Graph} element which contains its corresponding adjacency matrix.}¥
G (data, item) is a graph.
%%%% ¡settings!
'Graph'

¤%%% ¡prop!
SUB (data, item) is a subject.
%%%% ¡settings!
'Subject'¤

¤%%% ¡prop!
TARGET_IDS (parameter, stringlist) is a list of variable-of-interest IDs to be used as the class targets.¤

\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Graph_REG:tests,
	caption={
		{\bf NNDataPoint\_Graph\_REG element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_Graph\_REG.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]		
%% ¡tests!

%%% ¡excluded_props!
[NNDataPoint_Graph_REG.G NNDataPoint_Graph_REG.SUB]

%%% ¡test!
%%%% ¡name!¥\circled{1}\circlednote{1}{tests with the \code{GraphWU} element which contains weighted undirected adjacency matrix.}¥
Construct the data point with the adjacency matrix derived from its weighted undirected graph (GraphWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'CON_Group_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

% Analysis CON WU ¥\circled{2}\twocirclednotes{2}{3}{create the \code{AnalyzeEnsemble\_CON\_WU} element and then memorize its graph dictionary \code{G\_DICT}.}¥
a_WU = AnalyzeEnsemble_CON_WU( ...
    'GR', gr ...
    );

a_WU.memorize('G_DICT'); ¥\circled{3}¥

% create item lists of NNDataPoint_Graph_REG ¥\circled{4}\circlednote{4}{creates the \code{NNDataPoint\_Graph\_REG} element and use the \code{Graph} from \code{G\_DICT}.}¥
it_list = cellfun(@(g, sub) NNDataPoint_Graph_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_WU.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_Graph_REG DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Graph_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches ¥\circled{5}\circlednote{5}{tests whether the value of each input from the data point matches the graph's adjacency matrix.}¥
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name!¥\circled{6}\circlednote{6}{tests with the \code{MultigraphBUD} element which contains the adjacency matrix of binary undirected graph at fixed densities.}¥
Construct the data point with the adjacency matrix derived from its binary undirected multigraph with fixed densities (MultigraphBUD)
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'CON_Group_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

% Analysis CON WU
densities = 0:25:100;

a_BUD = AnalyzeEnsemble_CON_BUD( ...
    'DENSITIES', densities, ...
    'GR', gr ...
    );

a_BUD.memorize('G_DICT');

% create item lists of NNDataPoint_Graph_REG
it_list = cellfun(@(g, sub) NNDataPoint_Graph_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_BUD.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_Graph_REG DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Graph_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_BUD.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{7}\circlednote{7}{tests with the \code{MultiplexWU} element which contains the adjacency matrix of weighted undirected multipex.}¥
Construct the data point with the adjacency matrix derived from its multiplex weighted undirected graph (MultiplexWU)
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_SubjectCON_FUN_MP % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr_CON = im_gr.get('GR');

% Load Groups of SubjectFUN
im_gr = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr_FUN = im_gr.get('GR');

% Combine Groups of SubjectCON with Groups of SubjectFUN
co_gr = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr_CON, ...
    'GR_FUN', gr_FUN, ...
    'WAITBAR', true ...
    );

gr = co_gr.get('GR_CON_FUN_MP');

% Analysis CON FUN MP WU
a_WU = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'GR', gr ...
    );

a_WU.memorize('G_DICT');

% create item lists of NNDataPoint_Graph_REG
it_list = cellfun(@(g, sub) NNDataPoint_Graph_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_WU.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_Graph_REG DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Graph_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name!  ¥\circled{8}\circlednote{8}{tests with the \code{MultigraphBUT} element with the simulated connectivity data.}¥
Example script for binary undirected graph (MultigraphBUT) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end
example_NNCV_CON_BUT_REG

%%% ¡test!
%%%% ¡name! ¥\circled{9}\circlednote{9}{tests with the \code{MultiplexBUD} element with the simulated connectivity and functional data.}¥
Example script for binary undirected multiplex at fixed densities (MultiplexBUD) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_REG')) filesep 'Example data NN REG CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_REG % create example files
end
example_NNCV_CON_FUN_MP_BUD_REG

%%% ¡test!
%%%% ¡name! ¥\circled{10}\circlednote{10}{tests with the \code{MultiplexBUT} element with the simulated connectivity and functional data.}¥
Example script for binary undirected multiplex at fixed thresholds (MultiplexBUT) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_REG')) filesep 'Example data NN REG CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_REG % create example files
end
example_NNCV_CON_FUN_MP_BUT_REG

\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\subsection{Graph Data Point for Classification (\code{NNDataPoint\_Graph\_CLA})}

Now we implement \code{NNDataPoint\_Graph\_CLA} based on previous codes \code{NNDataPoint\_CON\_CLA}.
This neural network datapoint with graphs utilizes the adjacency matrix extracted from the derived graph of the subject. 
The modified parts of the code are highlighted.

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Graph_CLA:header,
	caption={
		{\bf NNDataPoint\_Graph\_CLA element header.}
		The \code{header} section of the generator code for \fn{\_NNDataPoint\_Graph\_CLA.gen.m} provides the general information about the \code{NNDataPoint\_Graph\_CLA} element.
		}
]
¤%% ¡header!¤
NNDataPoint_Graph_CLA < NNDataPoint (dp, graph classification data point) is a data point for classification with a graph.

¤%%% ¡description!¤
A data point for classification with a graph (NNDataPoint_Graph_CLA) 
 contains both input and target for neural network analysis.
The input is the value of the adjacency matrix extracted from the derived graph of the subject.
The target is obtained from the variables of interest of the subject.
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:NNDataPoint_Graph_CLA:prop_update},
	caption={
		{\bf NNDataPoint\_Graph\_CLA element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNDataPoint\_Graph\_CLA.gen.m} updates the properties of the \code{NNDataPoint\_Graph\_CLA} element. This defines the core properties of the data point.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of a data point for classification with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_CLA'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of a data point for classification with ¤a graph¤.
%%%% ¡default!¤
'A data point for classification with a graph (NNDataPoint_Graph_CLA) contains both input and target for neural network analysis. The input is the value of the adjacency matrix extracted from the derived graph of the subject. The target is obtained from the variables of interest of the subject.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of a data point for classification with ¤a graph¤.
%%%% ¡settings!¤
'NNDataPoint_Graph_CLA'

¤%%% ¡prop!
ID (data, string) is a few-letter code for a data point for classification with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_CLA ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of a data point for classification with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_CLA label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about a data point for classification with ¤a graph¤.
%%%% ¡default!¤
'NNDataPoint_Graph_CLA notes'

¤%%% ¡prop!
INPUT (result, cell) is the input value for this data point.
%%%% ¡calculate!¤
value = dp.get('G').get('A');  ¥\circled{1}\circlednote{1}{extracts the adjacency matrix from a \code{Graph} element as the input for this data point. Note that a \code{Graph} can be any kind of \code{Graph}, including \code{GraphWU}, \code{MultigraphBUD}, and \code{MultiplexBUT}, among others.}¥
    
¤%%% ¡prop!
TARGET (result, cell) is the target value for this data point.
%%%% ¡calculate!
value = dp.get('TARGET_IDS');¤

\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_Graph_CLA:props},
	caption={
		{\bf NNDataPoint\_Graph\_CLA element props.}
		The \code{props} section of generator code for \fn{\_NNDataPoint\_Graph\_CLA.gen.m} defines the properties to be used in \fn{NNDataPoint\_Graph\_CLA}.
	}
]
¤%% ¡props!¤

%%% ¡prop!  ¥\circled{1}\circlednote{1}{defines the \code{Graph} element which contains its corresponding adjacency matrix.}¥
G (data, item) is a graph.
%%%% ¡settings!
'Graph'

¤%%% ¡prop!
TARGET_IDS (parameter, stringlist) is a list of variable-of-interest IDs to be used as the class targets.¤

\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Graph_CLA:tests,
	caption={
		{\bf NNDataPoint\_Graph\_CLA element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_Graph\_CLA.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]		
%% ¡tests!

%%% ¡excluded_props!
[NNDataPoint_Graph_CLA.G]

%%% ¡test!
%%%% ¡name! ¥\circled{1}\circlednote{1}{tests with the \code{GraphWU} element which contains weighted undirected adjacency matrix.}¥
Construct the data point with the adjacency matrix derived from its weighted undirected graph (GraphWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_1_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_2_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% Analysis CON WU
a_WU1 = AnalyzeEnsemble_CON_WU( ...
    'GR', gr1 ...
    );

a_WU2 = AnalyzeEnsemble_CON_WU( ...
    'TEMPLATE', a_WU1, ...
    'GR', gr2 ...
    );

a_WU1.memorize('G_DICT');
a_WU2.memorize('G_DICT');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Graph_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU1.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU2.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{2}\circlednote{2}{tests with the \code{MultigraphBUD} element which contains binary undirected adjacency matrix at fixed densities.}¥
Construct the data point with the adjacency matrix derived from its binary undirected multigraph with fixed densities (MultigraphBUD)
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_1_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_2_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% Analysis CON WU
densities = 0:25:100;

a_BUD1 = AnalyzeEnsemble_CON_BUD( ...
    'DENSITIES', densities, ...
    'GR', gr1 ...
    );

a_BUD2 = AnalyzeEnsemble_CON_BUD( ...
    'TEMPLATE', a_BUD1, ...
    'GR', gr2 ...
    );

a_BUD1.memorize('G_DICT');
a_BUD2.memorize('G_DICT');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_BUD1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_BUD2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Graph_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_BUD1.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_BUD2.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{3}\circlednote{3}{tests with the \code{MultiplexWU} element which contains weighted undirected adjacency matrix from multiplex graph.}¥
Construct the data point with the adjacency matrix derived from its multiplex weighted undirected graph (MultiplexWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_SubjectCON_FUN_MP % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1_CON = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_2_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2_CON = im_gr2.get('GR');

% Load Groups of SubjectFUN
im_gr1 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1_FUN = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_2_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2_FUN = im_gr2.get('GR');

% Combine Groups of SubjectCON with Groups of SubjectFUN
co_gr1 = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr1_CON, ...
    'GR_FUN', gr1_FUN, ...
    'WAITBAR', true ...
    );

gr1 = co_gr1.get('GR_CON_FUN_MP');

co_gr2 = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr2_CON, ...
    'GR_FUN', gr2_FUN, ...
    'WAITBAR', true ...
    );

gr2 = co_gr2.get('GR_CON_FUN_MP');

% Analysis CON FUN MP WU
a_WU1 = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'GR', gr1 ...
    );

a_WU2 = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'TEMPLATE', a_WU1, ...
    'GR', gr2 ...
    );

a_WU1.memorize('G_DICT');
a_WU2.memorize('G_DICT');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Graph_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Graph_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Graph_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Graph_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU1.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = a_WU2.get('G_DICT').get('IT', index).get('A');

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Graph_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Graph_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{4}\circlednote{4}{tests with the \code{GraphWU} element with simulated data.}¥
Example script for weighted undirected graph (GraphWU) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end
example_NNCV_CON_WU_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{5}\circlednote{5}{tests with the \code{MultigraphBUD} element with simulated data.}¥
Example script for binary undirected graph at fixed densities (MultigraphBUD) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end
example_NNCV_CON_BUD_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{6}\circlednote{6}{tests with the \code{MultiplexWU} element with simulated data.}¥
Example script for weighted undirected multiplex (MultiplexWU) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_CLA')) filesep 'Example data NN CLA CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_CLA % create example files
end
example_NNCV_CON_FUN_MP_WU_CLA

\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of a Data Point with Graph Measures}
\subsection{Graph Measure Data Point for Regression (\code{NNDataPoint\_Measure\_REG})}

Now we implement \code{NNDataPoint\_Measure\_REG} based on previous codes \code{NNDataPoint\_Graph\_REG}.
This neural network datapoint utilizes graph measures obtrained from the adjacency matrix from the derived graph of the subject. 
The modified parts of the code are highlighted.

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Measure_REG:header,
	caption={
		{\bf NNDataPoint\_Measure\_REG element header.}
		The \code{header} section of the generator code for \fn{\_NNDataPoint\_Measure\_REG.gen.m} provides the general information about the \code{NNDataPoint\_Measure\_REG} element.
		}
]
¤%% ¡header!¤
NNDataPoint_Measure_REG < NNDataPoint (dp, measure regression data point)  is a data point for regression with graph measures.

¤%%% ¡description!¤
A data point for regression with graph measures (NNDataPoint_Measure_REG) 
 contains both input and target for neural network analysis.
The input is the value of the graph measures (e.g. Degree, DegreeAv, and Distance), 
 calculated from the derived graph of the subject.
The target is obtained from the variables of interest of the subject.
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:NNDataPoint_Measure_REG:prop_update},
	caption={
		{\bf NNDataPoint\_Measure\_REG element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNDataPoint\_Measure\_REG.gen.m} updates the properties of the \code{NNDataPoint\_Measure\_REG} element. This defines the core properties of the data point.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of a data point for regression with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_REG'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of a data point for regression with ¤graph measures¤.
%%%% ¡default!¤
'A data point for regression with graph measures (NNDataPoint_Measure_REG) contains both input and target for neural network analysis. The input is the value of the graph measures (e.g. Degree, DegreeAv, and Distance), calculated from the derived graph of the subject. The target is obtained from the variables of interest of the subject.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of a data point for regression with ¤graph measures¤.
%%%% ¡settings!¤
'NNDataPoint_Measure_REG'

¤%%% ¡prop!
ID (data, string) is a few-letter code for a data point for regression with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_REG ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of a data point for regression with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_REG label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about a data point for regression with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_REG notes'

¤%%% ¡prop!
INPUT (result, cell) is the input value for this data point.
%%%% ¡calculate!¤ 
value = cellfun(@(m_class) dp.get('G').get('MEASURE', m_class).get('M'), dp.get('M_LIST'), 'UniformOutput', false);  ¥\circled{1}\circlednote{1}{calculates or extract the graph measures, which are specified with \code{M\_LIST} from a \code{Graph} element for this data point. Note that a \code{Graph} can be any kind of \code{Graph}, including \code{GraphWU}, \code{MultigraphBUD}, and \code{MultiplexBUT}, among others.}¥
    
¤%%% ¡prop!
TARGET (result, cell) is the target value for this data point.
%%%% ¡calculate!
value = cellfun(@(x) dp.get('SUB').get('VOI_DICT').get('IT', x).get('V'), dp.get('TARGET_IDS'), 'UniformOutput', false);¤

\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_Measure_REG:props},
	caption={
		{\bf NNDataPoint\_Measure\_REG element props.}
		The \code{props} section of generator code for \fn{\_NNDataPoint\_Measure\_REG.gen.m} defines the properties to be used in \fn{NNDataPoint\_Measure\_REG}.
	}
]
¤%% ¡props!¤

¤%%% ¡prop!  
G (data, item) is a graph.
%%%% ¡settings!
'Graph'¤

%%% ¡prop! ¥\circled{1}\circlednote{1}{defines the graph measure list which will be obtained as \code{INPUT} for this data point.}¥
M_LIST (parameter, classlist) is a list of graph measure to be used as the input

¤%%% ¡prop!
SUB (data, item) is a subject.
%%%% ¡settings!
'Subject'¤

¤%%% ¡prop!
TARGET_IDS (parameter, stringlist) is a list of variable-of-interest IDs to be used as the class targets.¤

\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Measure_REG:tests,
	caption={
		{\bf NNDataPoint\_Measure\_REG element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_Measure\_REG.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]		
%% ¡tests!

%%% ¡excluded_props!
[NNDataPoint_Measure_REG.G NNDataPoint_Measure_REG.SUB]

%%% ¡test!
%%%% ¡name! ¥\circled{1}\fourcirclednotes{1}{2}{3}{4}{test adding various kinds of graph measure with the \code{GraphWU} element which contains weighted undirected adjacency matrix.}¥
Construct the data point with the adjacency matrix derived from its weighted undirected graph (GraphWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'CON_Group_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

% Analysis CON WU
a_WU = AnalyzeEnsemble_CON_WU( ...
    'GR', gr ...
    );

a_WU.get('MEASUREENSEMBLE', 'Degree').get('M');  ¥\circled{2}¥
a_WU.get('MEASUREENSEMBLE', 'DegreeAv').get('M'); ¥\circled{3}¥
a_WU.get('MEASUREENSEMBLE', 'Distance').get('M'); ¥\circled{4}¥

% create item lists of NNDataPoint_Measure_REG
it_list = cellfun(@(g, sub) NNDataPoint_Measure_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_WU.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_Measure_REG DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Measure_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{5}\circlednote{5}{test adding various kinds of graph measure with the \code{MultigraphBUD}.}¥
Construct the data point with the adjacency matrix derived from its binary undirected multigraph with fixed densities (MultigraphBUD)
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'CON_Group_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr = im_gr.get('GR');

% Analysis CON WU
densities = 0:25:100;

a_BUD = AnalyzeEnsemble_CON_BUD( ...
    'DENSITIES', densities, ...
    'GR', gr ...
    );

a_BUD.get('MEASUREENSEMBLE', 'Degree').get('M');
a_BUD.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_BUD.get('MEASUREENSEMBLE', 'Distance').get('M');

% create item lists of NNDataPoint_Measure_REG
it_list = cellfun(@(g, sub) NNDataPoint_Measure_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_BUD.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_CON_CLA DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Measure_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_BUD.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{6}\circlednote{6}{test adding various kinds of graph measure with the \code{MultiplexWU}.}¥
Construct the data point with the adjacency matrix derived from its multiplex weighted undirected graph (MultiplexWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_SubjectCON_FUN_MP % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr_CON = im_gr.get('GR');

% Load Groups of SubjectFUN
im_gr = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr_FUN = im_gr.get('GR');

% Combine Groups of SubjectCON with Groups of SubjectFUN
co_gr = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr_CON, ...
    'GR_FUN', gr_FUN, ...
    'WAITBAR', true ...
    );

gr = co_gr.get('GR_CON_FUN_MP');

% Analysis CON FUN MP WU
a_WU = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'GR', gr ...
    );

% To be added the multiplex measures
a_WU.get('MEASUREENSEMBLE', 'Degree').get('M');
a_WU.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_WU.get('MEASUREENSEMBLE', 'Distance').get('M');

% create item lists of NNDataPoint_Measure_REG
it_list = cellfun(@(g, sub) NNDataPoint_Measure_REG( ...
    'ID', sub.get('ID'), ...
    'G', g, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'SUB', sub, ...
    'TARGET_IDS', sub.get('VOI_DICT').get('KEYS')), ...
    a_WU.get('G_DICT').get('IT_LIST'), gr.get('SUB_DICT').get('IT_LIST'),...
    'UniformOutput', false);

% create NNDataPoint_Measure_REG DICT items
dp_list = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_REG', ...
        'IT_LIST', it_list ...
        );

% create a NNDataset containing the NNDataPoint_Measure_REG DICT
d = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_REG', ...
    'DP_DICT', dp_list ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr.get('SUB_DICT').get('LENGTH')
    individual_input = d.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_REG:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_REG does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{7}\circlednote{7}{test adding various kinds of graph measure with the \code{GraphWU} using example data.}¥
Example script for weighted undirected graph (GraphWU) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_REG')) filesep 'Example data NN REG CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_REG % create example files
end
example_NNCV_CON_WU_M_REG

%%% ¡test!
%%%% ¡name! ¥\circled{8}\circlednote{8}{test adding various kinds of graph measure with the \code{MultiplexWU} using example data.}¥
Example script for weighted undirected multiplex (MultiplexWU) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_REG')) filesep 'Example data NN REG CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_REG % create example files
end
example_NNCV_CON_FUN_MP_WU_M_REG

\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\subsection{Graph Measure Data Point for Classification (\code{NNDataPoint\_Measure\_CLA})}

Now we implement \code{NNDataPoint\_Measure\_CLA} based on previous codes \code{NNDataPoint\_Graph\_CLA}.
This neural network datapoint utilizes graph measures obtrained from the adjacency matrix from the derived graph of the subject. 
The modified parts of the code are highlighted.

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Measure_CLA:header,
	caption={
		{\bf NNDataPoint\_Measure\_CLA element header.}
		The \code{header} section of the generator code for \fn{\_NNDataPoint\_Measure\_CLA.gen.m} provides the general information about the \code{NNDataPoint\_Measure\_CLA} element.
		}
]
¤%% ¡header!¤
NNDataPoint_Measure_CLA < NNDataPoint (dp, measure classification data point) is a data point for classification with graph measures.

¤%%% ¡description!¤
A data point for classification with graph measures (NNDataPoint_Measure_CLA) 
 contains both input and target for neural network analysis.
The input is the value of the graph measures (e.g. Degree, DegreeAv, and Distance), 
 calculated from the derived graph of the subject.
The target is obtained from the variables of interest of the subject.
\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_Measure_CLA:prop_update},
	caption={
		{\bf NNDataPoint\_Measure\_CLA element prop update.}
		The \code{props\_update} section of the generator code for \fn{\_NNDataPoint\_Measure\_CLA.gen.m} updates the properties of the \code{NNDataPoint\_Measure\_CLA} element. This defines the core properties of the data point.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of a data point for classification with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_CLA'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of a data point for classification with ¤graph measures¤.
%%%% ¡default!¤
'A data point for classification with graph measures (NNDataPoint_Measure_CLA) contains both input and target for neural network analysis. The input is the value of the graph measures (e.g. Degree, DegreeAv, and Distance), calculated from the derived graph of the subject. The target is obtained from the variables of interest of the subject.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of a data point for classification with ¤graph measures¤.
%%%% ¡settings!¤
'NNDataPoint_Measure_CLA'

¤%%% ¡prop!
ID (data, string) is a few-letter code for a data point for classification with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_CLA ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of a data point for classification with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_CLA label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about a data point for classification with ¤graph measures¤.
%%%% ¡default!¤
'NNDataPoint_Measure_CLA notes'

¤%%% ¡prop!
INPUT (result, cell) is the input value for this data point.
%%%% ¡calculate!¤ 
value = cellfun(@(m_class) dp.get('G').get('MEASURE', m_class).get('M'), dp.get('M_LIST'), 'UniformOutput', false);  ¥\circled{1}\circlednote{1}{calculates or extract the graph measures, which are specified with \code{M\_LIST} from a \code{Graph} element for this data point. Note that a \code{Graph} can be any kind of \code{Graph}, including \code{GraphWU}, \code{MultigraphBUD}, and \code{MultiplexBUT}, among others.}¥
    
¤%%% ¡prop!
TARGET (result, cell) is the target value for this data point.
%%%% ¡calculate!
value = dp.get('TARGET_IDS');¤

\end{lstlisting}

\begin{lstlisting}[
	label={cd:m:NNDataPoint_Measure_CLA:props},
	caption={
		{\bf NNDataPoint\_Measure\_CLA element props.}
		The \code{props} section of generator code for \fn{\_NNDataPoint\_Measure\_CLA.gen.m} defines the properties to be used in \fn{NNDataPoint\_Measure\_CLA}.
	}
]
¤%% ¡props!¤

¤%%% ¡prop!  
G (data, item) is a graph.
%%%% ¡settings!
'Graph'¤

%%% ¡prop! ¥\circled{1}\circlednote{1}{defines the graph measure list which will be obtained as \code{INPUT} for this data point.}¥
M_LIST (parameter, classlist) is a list of graph measure to be used as the input

¤%%% ¡prop!
TARGET_IDS (parameter, stringlist) is a list of variable-of-interest IDs to be used as the class targets.¤

\end{lstlisting}

\clearpage

\begin{lstlisting}[
	label=cd:m:NNDataPoint_Measure_CLA:tests,
	caption={
		{\bf NNDataPoint\_Measure\_CLA element tests.}
		The \code{tests} section from the element generator \fn{\_NNDataPoint\_Measure\_CLA.gen.m}.
		A test for creating example files should be prepared to test the properties of the data point. Furthermore, additional test should be prepared for validating the value of input and target for the data point.
	}
]		
%% ¡tests!

%%% ¡excluded_props!
[NNDataPoint_Measure_CLA.G]

%%% ¡test!
%%%% ¡name! ¥\circled{1}\fourcirclednotes{1}{2}{3}{4}{test adding various kinds of graph measure with the \code{GraphWU} element which contains weighted undirected adjacency matrix.}¥
Construct the data point with the graph measures derived from its weighted undirected graph (GraphWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_1_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_2_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% Analysis CON WU
a_WU1 = AnalyzeEnsemble_CON_WU( ...
    'GR', gr1 ...
    );

a_WU2 = AnalyzeEnsemble_CON_WU( ...
    'TEMPLATE', a_WU1, ...
    'GR', gr2 ...
    );

a_WU1.get('MEASUREENSEMBLE', 'Degree').get('M');  ¥\circled{2}¥
a_WU1.get('MEASUREENSEMBLE', 'DegreeAv').get('M'); ¥\circled{3}¥
a_WU1.get('MEASUREENSEMBLE', 'Distance').get('M'); ¥\circled{4}¥

a_WU2.get('MEASUREENSEMBLE', 'Degree').get('M');
a_WU2.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_WU2.get('MEASUREENSEMBLE', 'Distance').get('M');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Measure_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU1.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU2.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{5}\circlednote{5}{test adding various kinds of graph measure with the \code{MultigraphBUD}.}¥
Construct the data point with the graph measures derived from its binary undirected multigraph with fixed densities (MultigraphBUD)
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_1_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1 = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'CON_Group_2_XLS'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2 = im_gr2.get('GR');

% Analysis CON WU
densities = 0:25:100;

a_BUD1 = AnalyzeEnsemble_CON_BUD( ...
    'DENSITIES', densities, ...
    'GR', gr1 ...
    );

a_BUD2 = AnalyzeEnsemble_CON_BUD( ...
    'TEMPLATE', a_BUD1, ...
    'GR', gr2 ...
    );

a_BUD1.get('MEASUREENSEMBLE', 'Degree').get('M');
a_BUD1.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_BUD1.get('MEASUREENSEMBLE', 'Distance').get('M');

a_BUD2.get('MEASUREENSEMBLE', 'Degree').get('M');
a_BUD2.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_BUD2.get('MEASUREENSEMBLE', 'Distance').get('M');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_BUD1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_BUD2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Measure_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_BUD1.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_BUD2.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name!
Construct the data point with the graph measures derived from its multiplex weighted undirected graph (MultiplexWU) 
%%%% ¡code!
% ensure the example data is generated
if ~isfile([fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_SubjectCON_FUN_MP % create example files
end

% Load BrainAtlas
im_ba = ImporterBrainAtlasXLS( ...
    'FILE', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'atlas.xlsx'], ...
    'WAITBAR', true ...
    );

ba = im_ba.get('BA');

% Load Groups of SubjectCON
im_gr1 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1_CON = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectCON_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_2_XLS.CON'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2_CON = im_gr2.get('GR');

% Load Groups of SubjectFUN
im_gr1 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_1_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr1_FUN = im_gr1.get('GR');

im_gr2 = ImporterGroupSubjectFUN_XLS( ...
    'DIRECTORY', [fileparts(which('SubjectCON_FUN_MP')) filesep 'Example data CON_FUN_MP XLS' filesep 'CON_FUN_MP_Group_2_XLS.FUN'], ...
    'BA', ba, ...
    'WAITBAR', true ...
    );

gr2_FUN = im_gr2.get('GR');

% Combine Groups of SubjectCON with Groups of SubjectFUN
co_gr1 = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr1_CON, ...
    'GR_FUN', gr1_FUN, ...
    'WAITBAR', true ...
    );

gr1 = co_gr1.get('GR_CON_FUN_MP');

co_gr2 = CombineGroups_CON_FUN_MP( ...
    'GR_CON', gr2_CON, ...
    'GR_FUN', gr2_FUN, ...
    'WAITBAR', true ...
    );

gr2 = co_gr2.get('GR_CON_FUN_MP');

% Analysis CON FUN MP WU
a_WU1 = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'GR', gr1 ...
    );

a_WU2 = AnalyzeEnsemble_CON_FUN_MP_WU( ...
    'TEMPLATE', a_WU1, ...
    'GR', gr2 ...
    );

% To be added the multiplex measures
a_WU1.get('MEASUREENSEMBLE', 'Degree').get('M');
a_WU1.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_WU1.get('MEASUREENSEMBLE', 'Distance').get('M');

a_WU2.get('MEASUREENSEMBLE', 'Degree').get('M');
a_WU2.get('MEASUREENSEMBLE', 'DegreeAv').get('M');
a_WU2.get('MEASUREENSEMBLE', 'Distance').get('M');

% create item lists of NNDataPoint_Graph_CLA
[~, group_folder_name] = fileparts(im_gr1.get('DIRECTORY'));
it_list1 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU1.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

[~, group_folder_name] = fileparts(im_gr2.get('DIRECTORY'));
it_list2 = cellfun(@(x) NNDataPoint_Measure_CLA( ...
    'ID', x.get('ID'), ...
    'G', x, ...
    'M_LIST', {'Degree' 'DegreeAv' 'Distance'}, ...
    'TARGET_IDS', {group_folder_name}), ...
    a_WU2.get('G_DICT').get('IT_LIST'), ...
    'UniformOutput', false);

% create NNDataPoint_Graph_CLA DICT items
dp_list1 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list1 ...
        );

dp_list2 = IndexedDictionary(...
        'IT_CLASS', 'NNDataPoint_Measure_CLA', ...
        'IT_LIST', it_list2 ...
        );

% create a NNDataset containing the NNDataPoint_Measure_CLA DICT
d1 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list1 ...
    );

d2 = NNDataset( ...
    'DP_CLASS', 'NNDataPoint_Measure_CLA', ...
    'DP_DICT', dp_list2 ...
    );

% Check whether the content of input for a single datapoint matches
for index = 1:1:gr1.get('SUB_DICT').get('LENGTH')
    individual_input = d1.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU1.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

for index = 1:1:gr2.get('SUB_DICT').get('LENGTH')
    individual_input = d2.get('DP_DICT').get('IT', index).get('INPUT');
    known_input = cellfun(@(m) m.get('M'), a_WU2.get('G_DICT').get('IT', index).get('M_DICT').get('IT_LIST'), 'UniformOutput', false);

    assert(isequal(individual_input, known_input), ...
        [BRAPH2.STR ':NNDataPoint_Measure_CLA:' BRAPH2.FAIL_TEST], ...
        'NNDataPoint_Measure_CLA does not construct the dataset correctly. The input value is not derived correctly.' ...
        )
end

%%% ¡test!
%%%% ¡name! ¥\circled{6}\circlednote{6}{test adding various kinds of graph measure with the \code{MultigraphBUD} using example connectivity data.}¥
Example script for binary undirected graph at fixed densities (GraphBUD) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end
example_NNCV_CON_BUD_M_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{7}\circlednote{7}{test adding various kinds of graph measure with the \code{MultigraphBUT} using example data.}¥
Example script for binary undirected graph at fixed thresholds (MultigraphBUT) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end
example_NNCV_CON_BUT_M_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{8}\circlednote{8}{test adding various kinds of graph measure with the \code{MultigraphBUD} using example connectivity data.}¥
Example script for binary undirected graph at fixed densities (MultigraphBUD) using connectivity data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_CLA')) filesep 'Example data NN CLA CON XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_CLA % create example files
end
example_NNCV_CON_BUD_M_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{9}\circlednote{9}{test adding various kinds of graph measure with the \code{MultiplexBUD} using example functional data.}¥
Example script for binary undirected multiplex at fixed densities (MultiplexBUD) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_CLA')) filesep 'Example data NN CLA CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_CLA % create example files
end
example_NNCV_CON_FUN_MP_BUD_M_CLA

%%% ¡test!
%%%% ¡name! ¥\circled{10}\circlednote{10}{test adding various kinds of graph measure with the \code{MultiplexBUT} using example functional data.}¥
Example script for binary undirected multiplex at fixed thresholds (MultiplexBUT) using connectivity data and functional data
%%%% ¡code!
if ~isfile([fileparts(which('NNDataPoint_CON_FUN_MP_CLA')) filesep 'Example data NN CLA CON_FUN_MP XLS' filesep 'atlas.xlsx'])
    test_NNDataPoint_CON_FUN_MP_CLA % create example files
end
example_NNCV_CON_FUN_MP_BUT_M_CLA

\end{lstlisting}

%\bibliography{biblio}
%\bibliographystyle{plainnat}

\end{document}