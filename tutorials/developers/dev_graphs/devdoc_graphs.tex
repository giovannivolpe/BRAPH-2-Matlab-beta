\documentclass{tufte-handout}
\usepackage{braph2_dev}
%\geometry{showframe} % display margins for debugging page layout

\title{Implement a new Graph}

\author[The BRAPH~2 Developers]{The BRAPH~2 Developers}

\begin{document}

\maketitle

\begin{abstract}
\noindent
This is the developer tutorial for implementing a new graph. 
In this Tutorial, we will explain how to create the generator file \fn{*.gen.m} for a new graph which can the be compiled by \code{braph2genesis}, using the graphs \code{GraphBD}, \code{MultilayerWU}, \code{Multiplex??}, \code{OrdMl??} as examples. and \code{OrdMx??} as examples.
\end{abstract}

\tableofcontents

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Unilayer Graph}

\subsection{Unilayer Graph Binary Directed (GraphBD)}

We will start by implementing in detail the graph \code{GraphBD} which  is a direct extension of the element \code{Graph}.

\begin{lstlisting}[
	label=cd:m:GraphBD:header,
	caption={
		{\bf GraphBD element header.}
		The \code{header} section of generator code for \fn{\_GraphBD.gen.m} provides the general information about the \code{GraphBD} element.
		}
]
%% ¡header!
GraphBD < Graph (m, binary directed graph) is a binary directed graph. ¥\circled{1}\circlednote{1}{The element \code{GraphBD} is defined as a subclass of \code{Graph}. The moniker will be \code{m}.}¥

%%% ¡description!
In a binary directed (BD) graph, the edges are directed and they can be 
either 0 (absence of connection) or 1 (existence of connection).
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:GraphBD:layout,
	caption={
		{\bf GraphBD element layout.}
		The \code{layout} section of generator code for \fn{\_GraphBD.gen.m} creates the general variables needed for the \code{GraphBD} element.
	}
	]
%% ¡layout!
%%% ¡prop!
%%%% ¡id!
GraphBD.ID
%%%% ¡title!
Graph ID

%%% ¡prop!
%%%% ¡id!
GraphBD.LABEL
%%%% ¡title!
Graph NAME

%%% ¡prop!
%%%% ¡id!
GraphBD.NODELABELS
%%%% ¡title!
NODES labels

%%% ¡prop!
%%%% ¡id!
GraphBD.B
%%%% ¡title!
Input ADJACENCY MATRIX

%%% ¡prop!
%%%% ¡id!
GraphBD.SEMIPOSITIVIZE_RULE
%%%% ¡title!
NEGATIVE WEIGHTS RULE

%%% ¡prop!
%%%% ¡id!
GraphBD.A
%%%% ¡title!
Binary Directed ADJACENCY MATRIX

%%% ¡prop!
%%%% ¡id!
GraphBD.PFGA
%%%% ¡title!
Adjacency Matrix Plot

%%% ¡prop!
%%%% ¡id!
GraphBD.PFGH
%%%% ¡title!
Graph Histogram

%%% ¡prop!
%%%% ¡id!
GraphBD.M_DICT
%%%% ¡title!
Graph MEASURES

%%% ¡prop!
%%%% ¡id!
GraphBD.NOTES
%%%% ¡title!
Graph NOTES
\end{lstlisting}


\begin{lstlisting}[
	label={cd:m:GraphBD:prop_update},
	caption={
		{\bf GraphBD element prop update.}
		The \code{props\_update} section of generator code for \fn{GraphBD.gen.m} updates the properties of the \code{Graph} element. This defines the core properties of the graph.
	}
]
%% ¡props_update!
%%% ¡prop!
NAME (constant, string) is the name of the binary directed graph.
%%%% ¡default!
'GraphBD'

%%% ¡prop!
DESCRIPTION (constant, string) is the description of the  binary directed graph.
%%%% ¡default!
'In a binary directed (BD) graph, the edges are directed and they can be either 0 (absence of connection) or 1 (existence of connection).'

%%% ¡prop!
TEMPLATE (parameter, item) is the template of the  binary directed graph.

%%% ¡prop!
ID (data, string) is a few-letter code of the  binary directed graph.
%%%% ¡default!
'GraphBD ID'

%%% ¡prop!
LABEL (metadata, string) is an extended label of the binary directed graph.
%%%% ¡default!
'GraphBD label'

%%% ¡prop!
NOTES (metadata, string) are some specific notes about the binary directed graph.
%%%% ¡default!
'GraphBD notes'

%%% ¡prop! ¥\circled{1}\circlednote{1}{We need to define the type of graph: \code{Graph.GRAPH} (consists of a single layer), \code{Graph.MULTIGRAPH} (multiple unconnected layers of graphs), \code{Graph.MULTILAYER} (multiple layers with categorical connections between any nodes), \code{Graph.ORDERED\_MULTILAYER} (multiple layers with ordinal connections between any nodes) \code{Graph.MULTIPLEX} (multilayer graph where only interlayer edges are allowed between homologous nodes) and \code{Graph.ORDERED\_MULTIPLEX} (multiplex graph that consists of a sequence of layers with ordinal edges between corresponding nodes in subsequent layers).}¥
GRAPH_TYPE (constant, scalar) returns the graph type __Graph.GRAPH__.
%%%% ¡default!
Graph.GRAPH

%%% ¡prop! ¥\circled{2}\circlednote{2}{Graphs have a \emph{CONNECTIVITY\_TYPE}: \code{Graph.BINARY} (Graph with binary, 0 or 1, connections) or \code{Graph.WEIGHTED} (Graph with weighted connections).}¥
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type __Graph.BINARY__.
%%%% ¡default!
value = Graph.BINARY;

%%% ¡prop! ¥\circled{3}\circlednote{3}{Graphs have a \emph{DIRECTIONALITY\_TYPE}: \code{Graph.DIRECTED} (graph with directed edges) or \code{Graph.UNDIRECTED} (graph with undirected edges). }¥
DIRECTIONALITY_TYPE  (query, smatrix) returns the directionality type __Graph.DIRECTED__.
%%%% ¡default!
value = Graph.DIRECTED;

%%% ¡prop! ¥\circled{4}\circlednote{4}{Graphs have a \emph{SELFCONNECTIVITY\_TYPE}: \code{Graph.NONSELFCONNECTED} (Graph without self-connections) or \code{Graph.SELFCONNECTED} (Graph with self-connections). }¥
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type __Graph.NONSELFCONNECTED__.
%%%% ¡default!
value = Graph.NONSELFCONNECTED;

%%% ¡prop! ¥\circled{5}\circlednote{5}{Graphs have a \emph{NEGATIVITY\_TYPE}: \code{Graph.NONNEGATIVE} (Graph without negative edges) or \code{Graph.NEGATIVE} (Graph allowing negative edges). }¥
NEGATIVITY_TYPE (query, smatrix) returns the negativity type __Graph.NONNEGATIVE__.
%%%% ¡default!
value = Graph.NONNEGATIVE;

%%% ¡prop! ¥\circled{6}\circlednote{6}{The property \code{A} contains the code to be executed to calculate the graph.}¥
A (result, cell) is the binary adjacency matrix of the binary directed graph.
%%%% ¡calculate!
B = g.get('B'); ¥\circled{7}\circlednote{7}{retrieves the cell with the adjacency matrix of the graph}¥

B = dediagonalize(B);  ¥\circled{8}\circlednote{8}{Apply corresponding functions to define the properties of the graph:  \code{diagonalize} (removes the off-diagonal), \code{dediagonalize} (removes the diagonal),  \code{binarize} (binarizes with threshold=0), \code{semipositivize} (removes negative weights), \code{standardize} (normalizes between 0 and 1) or \code{symmetrize} (symmetrizes the matrix)}¥
B = semipositivize(B, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE')); 
B = binarize(B); 

A = {B}; ¥\circled{9}\circlednote{9}{preallocates the adjacency matrix that contains the result of the defined graph.}¥
value = A; ¥\circled{10}\circlednote{10}{returns the calcualted graph \code{A} assigning it to the output variable \code{value}.}¥

%%%% ¡gui! ¥\circled{11}\circlednote{11}{Each graph has a panel figure of the cell containing the graph adjacency matrix.}¥
pr = PanelPropCell('EL', g, 'PROP', GraphBD.A, ... ¥\circled{12}\circlednote{12}{ \code{PanelPropCell} plots the panel for a CELL property with a table and two sliders. It can be personalized with props, e.g., \code{TABLE\_HEIGHT} (height in pixels), \code{XSLIDERSHOW} (whether to show the x-slider),  or \code{COLUMNAME} (string list with column names)}¥
'TABLE_HEIGHT', s(40), ... 
'XSLIDERSHOW', false, ... 
'YSLIDERSHOW', false, ...  
'ROWNAME' , g.getCallback('ANODELABELS'), ... 
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
);








%%% ¡prop! ¥\circled{13}\circlednote{13}{Each graph has a list of compatible measures.}¥
COMPATIBLE_MEASURES (constant, classlist) is the list of compatible measures.
%%%% ¡default!
getCompatibleMeasures('GraphBD')

%%% ¡prop!¥\circled{14}\circlednote{14}{Each graph has a panel figure of the graph adjacency matrix.}¥
B (data, smatrix) is the input graph adjacency matrix.
%%%% ¡gui!
pr = PanelPropMatrix('EL', g, 'PROP', GraphBD.B, ... ¥\circled{15}\circlednote{15}{ \code{PanelPropMatrix} plots the panel of a property matrix-like with a table. It can be personalized with props as in \circled{12}).}¥
'TABLE_HEIGHT' , s(40), ...
'ROWNAME' , g.getCallback('ANODELABELS'), ... 
'COLUMNNAME', g.getCallback('ANODELABELS'), ...
varargin{:});

%%% ¡prop! ¥\circled{16}\circlednote{16}{Each graph have different rules that need to be defined: \code{SYMMETRIZE\_RULE}: symmetrizes the matrix A by the symmetrize rule specified by RULE and the admissible RULE options are: 'max' (default,maximum between inconnection and outconnection), 'sum' (convert negative values to absolute value), 'average' (average of inconnection and outconnection) or 'min' (minimum between inconnection and outconnection) \code{SEMIPOSITIVIZE\_RULE}: determines how to remove the negative edges and the admissible RULE options are: 'zero' (default, convert negative values to zeros) or 'absolute' (convert negative values to absolute value) \code{STANDARDIZE\_RULE }: determines how to normalize the weights between 0 and 1 and the admissible RULE options are: 'threshold' (default, normalizes the matrix A by converting negative values to zero and values larger than 1 to 1) or  'range' (normalizes the matrix A in order to have values scaled between 0 and 1 by using a linear function). }¥
SEMIPOSITIVIZE_RULE (parameter, option) determines how to remove the negative edges.
%%%% ¡settings!
{'zero', 'absolute'}

\end{lstlisting}

\clearpage


\begin{lstlisting}[
	label=cd:m:GraphBD:tests,
	caption={
		{\bf GraphBD element tests.}
		The \code{tests} section from the element generator \fn{\_GraphBD.gen.m}.
		A general test should be prepared to test the properties of the graph  when it is empty and full. Furthermore, additional tests should be prepared for the rules defined (one test per rule).
	}
	]		
		

%% ¡tests!

%%% ¡excluded_props!  ¥\circled{1}\circlednote{1}{List of properties that are excluded from testing.}¥
[GraphBD.PFGA GraphBD.PFGH]

%%% ¡test!
%%%% ¡name!
Constructor - Empty  ¥\circled{2}\circlednote{2}{Checks that an empty \fn{GraphBD} graph is constructing well}¥
%%%% ¡probability! ¥\circled{3}\circlednote{3}{Assigns a low test execution probability}¥
.01
%%%% ¡code!
B = []; ¥\circled{4}\circlednote{4}{Initializes an empty \fn{GraphBD} graph}¥
g = GraphBD('B', B);¥\circled{5}\circlednote{5}{Constructs the \fn{GraphBD} graph from the initialized \fn{B}}¥

g.get('A_CHECK'); ¥\circled{6}\circlednote{6}{Performs the corresponding checks for the format of the adjacency matrix \code{A}: \code{GRAPH\_TYPE}, \code{CONNECTIVITY\_TYPE}, \code{DIRECTIONALITY\_TYPE}, \code{SELFCONNECTIVITY\_TYPE} and \code{NEGATIVITY\_TYPE}.}¥

A = {binarize(semipositivize(dediagonalize(B)))}; ¥\circled{7}\circlednote{7}{Calculates the value of the graph by apply the corresponding properties function}¥
assert(isequal(g.get('A'), A), ...¥\circled{8}\circlednote{8}{tests that the value of generated graph calculated by applying the properties functions coincides with the expected value}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Constructor - Full ¥\circled{9}\circlednote{9}{Checks that a full \fn{GraphBD} graph is constructing well}¥
%%%% ¡probability!  ¥\circled{3}¥
.01  ¥\circled{3}¥
%%%% ¡code!
B = randn(randi(10)); ¥\circled{10}\circlednote{4}{Generates a random graph}¥
g = GraphBD('B', B);  ¥\circled{5}¥

g.get('A_CHECK') ¥\circled{6}¥

A = {binarize(semipositivize(dediagonalize(B)))}; ¥\circled{7}¥
assert(isequal(g.get('A'), A), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

%%% ¡test!
%%%% ¡name!
Semipositivize Rules ¥\circled{10}\circlednote{10}{Checks the \fn{SEMIPOSITIVIZE\_RULE} on the \fn{GraphBD} graph.}¥
%%%% ¡probability!
.01 ¥\circled{3}¥
%%%% ¡code!
B = [
-2 -1 0 1 2
-1 0 1 2 -2
0 1 2 -2 -1
1 2 -2 -1 0
2 -2 -1 0 1
]; ¥\circled{11}\circlednote{11}{Generates an example graph with negative weights}¥

g0 = GraphBD('B', B);  ¥\circled{12}\circlednote{12}{Constructs the \fn{GraphBD} graph from the initialized \fn{B} with default RULE for \fn{SEMIPOSITIVIZE\_RULE}. }¥
A0 = {[
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]};  ¥\circled{13}\circlednote{13}{Expected value of the graph calculated by external means}¥
assert(isequal(g0.get('A'), A0), ...  ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

g_zero = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'zero'); ¥\circled{14}\circlednote{14}{Constructs the \fn{GraphBD} graph from the initialized \fn{B} with RULE = 'zero' for \fn{SEMIPOSITIVIZE\_RULE}. }¥
A_zero = {[
	0 0 0 1 1
	0 0 1 1 0
	0 1 0 0 0
	1 1 0 0 0
	1 0 0 0 0
	]}; ¥\circled{13}¥
assert(isequal(g_zero.get('A'), A_zero), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

g_absolute = GraphBD('B', B, 'SEMIPOSITIVIZE_RULE', 'absolute'); ¥\circled{15}\circlednote{15}{Constructs the \fn{GraphBD} graph from the initialized \fn{B} with RULE = 'absolute' for \code{SEMIPOSITIVIZE\_RULE}}¥
A_absolute = {[
	0 1 0 1 1
	1 0 1 1 1
	0 1 0 1 1
	1 1 1 0 0
	1 1 1 0 0
	]}; ¥\circled{13}¥
assert(isequal(g_absolute.get('A'), A_absolute), ... ¥\circled{8}¥
[BRAPH2.STR ':GraphBD:' BRAPH2.FAIL_TEST], ...
'GraphBD is not constructing well.')

¤...¤
\end{lstlisting}

%%%%% %%%%% %%%%% %%%%% %%%%%
\clearpage
\section{Implementation of Multilayer Graph}

\subsection{Multilayer Weigthed Directed Graph (MultilayerWD )}


We can now use \code{GraphBD} as the basis to implement the global measure \code{MultilayerWD}.
The parts of the code that are modified are highlighted.

\begin{lstlisting}[
	label=cd:m:MultilayerWD:header,
	caption={
		{\bf MultilayerWD element header.}
		The \code{header} section of generator code for \fn{\_MultilayerWD.gen.m} provides the general information about the \code{MultilayerWD} element.
		\expand{cd:m:GraphBD:header}
	}
]
¤%% ¡header!¤
MultilayerWD ¤< Graph¤ (g, multilayer weighted directed graph) is a multilayer weighted directed graph.

¤%%% ¡description!¤
In a multilayer weighted directed (WD) graph, layers could have different number 
of nodes with within-layer weighted directed edges, associated with a real
number between 0 and 1 and indicating the strength of the connection.
The connectivity matrices are symmetric (within layer).
All node connections are allowed between layers.
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:prop_update,
	caption={
		{\bf MultilayerWD element prop update.}
		The \code{props\_update} section of generator code for \fn{\_MultilayerWD.gen.m} updates the properties of \code{MultilayerWD}.
	}
]
¤%% ¡props_update!¤

¤%%% ¡prop!
NAME (constant, string) is the name of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD'

¤%%% ¡prop!
DESCRIPTION (constant, string) is the description of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'In a multilayer weighted directed (WD) graph, layers could have different number 
of nodes with within-layer weighted directed edges, associated with a real
number between 0 and 1 and indicating the strength of the connection.
The connectivity matrices are symmetric (within layer).
All node connections are allowed between layers.'

¤%%% ¡prop!
TEMPLATE (parameter, item) is the template of the ¤multilayer weighted directed graph¤.¤

¤%%% ¡prop!
ID (data, string) is a few-letter code of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD ID'

¤%%% ¡prop!
LABEL (metadata, string) is an extended label of the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD label'

¤%%% ¡prop!
NOTES (metadata, string) are some specific notes about the ¤multilayer weighted directed graph¤.
%%%% ¡default!¤
'MultilayerWD notes'

¤%%% ¡prop!
GRAPH_TYPE (constant, scalar) returns the graph type¤ __Graph.MULTILAYER__.
%%%% ¡default!
Graph.MULTILAYER

¤%%% ¡prop!
CONNECTIVITY_TYPE (query, smatrix) returns the connectivity type¤ __Graph.WEIGHTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.WEIGHTED * ones(layernumber);

¤%%% ¡prop!
DIRECTIONALITY_TYPE (query, smatrix) returns the directionality type¤ __Graph.DIRECTED__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.DIRECTED * ones(layernumber);

¤%%% ¡prop!
SELFCONNECTIVITY_TYPE (query, smatrix) returns the self-connectivity type¤ __Graph.NONSELFCONNECTED__ on the diagonal and __Graph.SELFCONNECTED__ off diagonal.
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.SELFCONNECTED * ones(layernumber);
value(1:layernumber+1:end) = Graph.NONSELFCONNECTED;                

¤%%% ¡prop!
NEGATIVITY_TYPE (query, smatrix) returns the negativity type ¤__Graph.NONNEGATIVE__ * ones(layernumber).
%%%% ¡calculate!
if isempty(varargin)
layernumber = 1;
else
layernumber = varargin{1};
end
value = Graph.NONNEGATIVE * ones(layernumber);

¤%%% ¡prop!
A (result, cell) is the cell containing¤ the within-layer weighted adjacency matrices of the multilayer weighted directed graph and the connections between layers.

¤%%%% ¡calculate!
B = g.get('B'); ¤
L = length(B); 
A = cell(L, L);
for i = 1:1:L ¥\circled{1}\circlednote{1}{For each layer in \fn{MultilayerWD} graph the corresponding functions are applied as in Code~\ref{cd:m:GraphBD:prop_update} \circled{8}}¥
	M = dediagonalize(B{i,i}); 
	M = semipositivize(M, 'SemipositivizeRule', g.get('SEMIPOSITIVIZE_RULE'));
	M = standardize(M, 'StandardizeRule', g.get('STANDARDIZE_RULE'));  
	A(i, i) = {M};
	if ~isempty(A{i, i})
		for j = i+1:1:L
			M = semipositivize(B{i,j}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(i, j) = {M};
			M = semipositivize(B{j,i}, 'SemipositivizeRule', 	g.get('SEMIPOSITIVIZE_RULE')); 
			M = standardize(M, 'StandardizeRule', 	g.get('STANDARDIZE_RULE'));  
			A(j, i) = {M};
		end
	end
end
¤value = A;¤
\end{lstlisting}

\begin{lstlisting}[
	label=cd:m:MultilayerWD:tests,
	caption={
		{\bf MultilayerWD element tests.}
		The \code{tests} section from the element generator \fn{\_MultilayerWD.gen.m}.
	}
]
¤%% ¡tests!

%%% ¡excluded_props!¤
[MultilayerWD.PFGA MultilayerWD.PFGH]

¤%%% ¡test!
%%%% ¡name!
Constructor - Full
%%%% ¡probability!
.01
%%%% ¡code!¤
B1 = rand(randi(10));
B2 = rand(randi(10));
B3 = rand(randi(10));
B12 = rand(size(B1, 1),size(B2, 2));
B13 = rand(size(B1, 1),size(B3, 2));
B23 = rand(size(B2, 1),size(B3, 2));
B21 = rand(size(B2, 1),size(B1, 2));
B31 = rand(size(B3, 1),size(B1, 2));
B32 = rand(size(B3, 1),size(B2, 2));
B = {
	B1                           B12                            B13
	B21                          B2                             B23
	B31                          B32                            B3
};
g = MultilayerWD('B', B);
¤g.get('A_CHECK')¤
A1 = standardize(semipositivize(dediagonalize(B1)));
A2 = standardize(semipositivize(dediagonalize(B2)));
A3 = standardize(semipositivize(dediagonalize(B3)));
A12 = standardize(semipositivize(B12));
A13 = standardize(semipositivize(B13));
A23 = standardize(semipositivize(B23));
A21 = standardize(semipositivize(B21));
A31 = standardize(semipositivize(B31));
A32 = standardize(semipositivize(B32));
B{1,1} = A1;
B{2,2} = A2;
B{3,3} = A3;
B{1,2} = A12;
B{1,3} = A13;
B{2,3} = A23;
B{2,1} = A21;
B{3,1} = A31;
B{3,2} = A32;
A = B;
¤assert(isequal(g.get('A'), A), ...¤
¤[BRAPH2.STR ':¤ MultilayerWD:¤ ' BRAPH2.FAIL_TEST], ...¤
'MultilayerWD  is not constructing well.')

\end{lstlisting}


\clearpage

\subsection{Multiplex ..... Graph ( )}

\clearpage

\subsection{Ordinal Multilayer .....  Graph ( )}

\clearpage

\subsection{Ordinal Multiplex ... Graph ( )}

%\bibliography{biblio}
%\bibliographystyle{plainnat}

\end{document}
